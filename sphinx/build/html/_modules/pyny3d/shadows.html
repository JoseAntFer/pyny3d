<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyny3d.shadows &mdash; pyny3d 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyny3d 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>pyny3d 0.1 documentation</span></a></h1>
        <h2 class="heading"><span>pyny3d.shadows</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for pyny3d.shadows</h1><div class="highlight"><pre>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pyny3d.geoms</span> <span class="kn">as</span> <span class="nn">pyny</span>

<div class="viewcode-block" id="ShadowsManager"><a class="viewcode-back" href="../../doc.html#pyny3d.shadows.ShadowsManager">[docs]</a><span class="k">class</span> <span class="nc">ShadowsManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class in charge of the management for the shadows simulations.</span>
<span class="sd">    </span>
<span class="sd">    It can be initialize as standalone object or associated to a </span>
<span class="sd">    ``pyny.Space`` through the ``.shadow`` method.</span>
<span class="sd">    </span>
<span class="sd">    The only needed for the simulator to run is ``t`` or ``dt`` and </span>
<span class="sd">    the ``latitude``. If the ShadowsManager is initialized from</span>
<span class="sd">    ``pyny.Space.shadows`` it is possible to run the execution in auto</span>
<span class="sd">    mode without inputing anything.</span>
<span class="sd">    </span>
<span class="sd">    The shadows are computed discretely with a set of sparsed **sensible </span>
<span class="sd">    points** through the model. These points can be set with the </span>
<span class="sd">    ``.get_height`` or the ``mesh`` methods.</span>
<span class="sd">    </span>
<span class="sd">    At the same time, the sun positions are also discrete. The </span>
<span class="sd">    simulator needs a finite number of positions, given by their azimuth</span>
<span class="sd">    and zenit. Anyway, it is more convenient to give it a time vector and</span>
<span class="sd">    the latitude and let the program calculate the sun positions for </span>
<span class="sd">    you.</span>
<span class="sd">    </span>
<span class="sd">    For convenience, the time is managed in absolute minutes within the </span>
<span class="sd">    range of a year in the computations, that is, the first interval is </span>
<span class="sd">    the Jan 1 00:00 [0] and the last is Dec 31 23:59 [525599]. </span>
<span class="sd">    February 29 is not taken into account. It is also possible to </span>
<span class="sd">    automatically create an equally spaced t vector by giving a fixed</span>
<span class="sd">    interval.</span>
<span class="sd">    </span>
<span class="sd">    In view of the fact that there are, for example, more than 8000 </span>
<span class="sd">    sunnys half-hour intervals in an year, the program precomputes a </span>
<span class="sd">    discretization for the Solar Horizont (azimuth, zenit pairs) and </span>
<span class="sd">    classify the `t` vector and the data into it. The goal is to </span>
<span class="sd">    approximate these 8000 static simulations to a less than 340 with</span>
<span class="sd">    an error of lss than 3ยบ (0.05rads).</span>
<span class="sd">    </span>
<span class="sd">    This discretization is manually\* adjustable to be able to compute </span>
<span class="sd">    large datasets, arbitrarily distributed in time, very fast at </span>
<span class="sd">    low resolution before the serious computations start.</span>
<span class="sd">    </span>
<span class="sd">    For now, the Solar Horizont discretization can only be automatically </span>
<span class="sd">    computed by a mesh. In the future more complex and convenient</span>
<span class="sd">    discretizations will be available. Anyway, it is possible to input</span>
<span class="sd">    a custom discretization.</span>
<span class="sd">    </span>
<span class="sd">    The atributes which can be safely manipulated to tune up the simulator</span>
<span class="sd">    before the computations are all which start with *arg_* (default</span>
<span class="sd">    values):</span>

<span class="sd">        * .arg_data</span>
<span class="sd">        * .arg_t</span>
<span class="sd">        * .arg_dt</span>
<span class="sd">        * .arg_latitude = None</span>
<span class="sd">        * .arg_run_true_time = False</span>
<span class="sd">        * .arg_longitude = None (only for ``true_time``)</span>
<span class="sd">        * .arg_UTC = None (only for ``true_time``)</span>
<span class="sd">        * .arg_zenitmin = 0.1 (minimum zenit, avoid irrelevant errors </span>
<span class="sd">            from trigonometric approximations)</span>
<span class="sd">        * .arg_vor_size = 0.15 (mesh_size of the Voronoi diagram)</span>
<span class="sd">    </span>
<span class="sd">    :param space: 3D model to run the simulation.</span>
<span class="sd">    :type space: ``pyny.Space`` </span>
<span class="sd">    :param data: Data timeseries to project on the 3D model (radiation,</span>
<span class="sd">        for example).</span>
<span class="sd">    :type data: ndarray (shape=N), None</span>
<span class="sd">    :param t: Time vector in absolute minutes or datetime objects</span>
<span class="sd">    :type t: ndarray or list, None</span>
<span class="sd">    :param dt: Interval time to generate t vector.</span>
<span class="sd">    :type dt: int, None</span>
<span class="sd">    :param latitude: Local latitude.</span>
<span class="sd">    :type latitude: float (radians)</span>
<span class="sd">    :returns: None</span>
<span class="sd">        </span>
<span class="sd">    .. note:: \* In the future, the discretizations will be </span>
<span class="sd">        automated based on error adjustment.</span>
<span class="sd">    </span>
<span class="sd">    .. warning:: The shadows computation do not take care</span>
<span class="sd">        of the holes\*, instead, they can be emulated by a collection of </span>
<span class="sd">        polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">latitude</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyny3d.shadows</span> <span class="kn">import</span> <span class="n">Viz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viz</span> <span class="o">=</span> <span class="n">Viz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">=</span> <span class="n">space</span>
        <span class="c1"># Arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg_dt</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg_latitude</span> <span class="o">=</span> <span class="n">latitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg_run_true_time</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg_longitude</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg_UTC</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg_zenitmin</span> <span class="o">=</span> <span class="mf">0.05</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg_vor_size</span> <span class="o">=</span> <span class="mf">0.15</span>
        
        <span class="c1"># Processed information</span>
        <span class="c1">## Precalculations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diff_t</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integral</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c1">## Voronoi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t2vor_map</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vor_freq</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vor_surf</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vor_centers</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c1">## get_sunpos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_zenit</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">true_time</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c1">## compute_shadows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">light</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c1">## project_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_vor</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_points</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="ShadowsManager.run"><a class="viewcode-back" href="../../doc.html#pyny3d.shadows.ShadowsManager.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the shadowing computation with the values stored in </span>
<span class="sd">        ``self.arg_``. Precomputed information is stored in:</span>
<span class="sd">        </span>
<span class="sd">            * **.diff_t** (*ndarray*): ``np.diff(t)``</span>
<span class="sd">            * **.integral** (*ndarray*): ``data*np.diff(t)``</span>

<span class="sd">        The steps are:</span>
<span class="sd">        </span>
<span class="sd">            * :func:`get_sunpos`</span>
<span class="sd">            * :func:`Vonoroi_SH`</span>
<span class="sd">            * :func:`compute_shadows`</span>
<span class="sd">            * :func:`project_data`</span>
<span class="sd">        </span>
<span class="sd">        :retruns: None</span>
<span class="sd">        </span>
<span class="sd">        .. note:: In the future better ways to calculate ``integral``</span>
<span class="sd">            will be added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Adapt series</span>
        <span class="c1">## time</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">datetime</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_minutes</span><span class="p">(</span><span class="n">time_obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_dt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_dt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_minutes</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one time parameter is needed.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diff_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span><span class="p">)</span>
        
        <span class="c1">## data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">/</span><span class="mi">1000</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">diff_t</span><span class="o">/</span><span class="mi">60</span><span class="p">))</span>

        <span class="c1"># Computation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_sunpos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_run_true_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vonoroi_SH</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_vor_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_shadows</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">project_data</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="ShadowsManager.Vonoroi_SH"><a class="viewcode-back" href="../../doc.html#pyny3d.shadows.ShadowsManager.Vonoroi_SH">[docs]</a>    <span class="k">def</span> <span class="nf">Vonoroi_SH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a equally spaced mesh on the Solar Horizont (SH).</span>
<span class="sd">        </span>
<span class="sd">        Computes the Voronoi diagram from a set of points given by pairs</span>
<span class="sd">        of (azimuth, zenit) values. This discretization completely</span>
<span class="sd">        covers all the Sun positions.</span>
<span class="sd">        </span>
<span class="sd">        The smaller mesh size, the better resolution obtained. it is </span>
<span class="sd">        important to note that this affects the performance heavily.</span>
<span class="sd">        </span>
<span class="sd">        The generated information is stored in:</span>
<span class="sd">            * **.t2vor_map** (*ndarray*): Mapping between time vector and</span>
<span class="sd">              the Voronoi diagram.</span>
<span class="sd">            * **.vor_freq** (*ndarray*): Number of times a Sun position</span>
<span class="sd">              is inside each polygon in the Voronoi diagram.</span>
<span class="sd">            * **.vor_surf** (*``pyny.Surface``*): Voronoi diagram.</span>
<span class="sd">            * **.vor_centers** (*ndarray`*): Mass center of the </span>
<span class="sd">              ``pyny.Polygons`` that form the Voronoi diagram.</span>
<span class="sd">        </span>
<span class="sd">        :param mesh_size: Mesh size for the square discretization of the</span>
<span class="sd">            Solar Horizont.</span>
<span class="sd">        :type mesh_size: float (in radians)</span>
<span class="sd">        :param plot: If True, generates a visualization of the Voronoi</span>
<span class="sd">            diagram.</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :returns: None</span>
<span class="sd">        </span>
<span class="sd">        .. note:: In future versions this discretization will be</span>
<span class="sd">            improved substantially. For now, it is quite rigid and only</span>
<span class="sd">            admits square discretization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Voronoi</span>
        <span class="kn">from</span> <span class="nn">pyny3d.utils</span> <span class="kn">import</span> <span class="n">sort_numpy</span>
        
        <span class="c1"># Sort and remove NaNs</span>
        <span class="n">xy_sorted</span><span class="p">,</span> <span class="n">order_back</span> <span class="o">=</span> <span class="n">sort_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">azimuth_zenit</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                           <span class="n">order_back</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="c1"># New grid</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">mesh_size</span><span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">mesh_size</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">mesh_size</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">mesh_size</span><span class="p">)</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">y1</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
        
        <span class="c1"># Voronoi</span>
        <span class="n">vor</span> <span class="o">=</span> <span class="n">Voronoi</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
        
        <span class="c1"># Setting the SH polygons</span>
        <span class="n">pyny_polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">pyny</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">vor</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="bp">False</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vor</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">raw_surf</span> <span class="o">=</span> <span class="n">pyny</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">pyny_polygons</span><span class="p">)</span>
                                 
        <span class="c1"># Classify data into the polygons discretization</span>
        <span class="n">map_</span> <span class="o">=</span> <span class="n">raw_surf</span><span class="o">.</span><span class="n">classify</span><span class="p">(</span><span class="n">xy_sorted</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                 <span class="n">already_sorted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">map_</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">order_back</span><span class="p">]</span>
        
        <span class="c1"># Selecting polygons with points inside</span>
        <span class="n">vor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">poly_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">map_</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">vor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raw_surf</span><span class="p">[</span><span class="n">poly_i</span><span class="p">])</span>
            <span class="n">bool_0</span> <span class="o">=</span> <span class="n">map_</span><span class="o">==</span><span class="n">poly_i</span>
            <span class="n">count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bool_0</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="n">map_</span><span class="p">[</span><span class="n">bool_0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                
        <span class="c1"># Storing the information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t2vor_map</span> <span class="o">=</span> <span class="n">map_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vor_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vor_surf</span> <span class="o">=</span> <span class="n">pyny</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">vor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vor_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">get_centroid</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span> 
                                     <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vor_surf</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="ShadowsManager.get_sunpos"><a class="viewcode-back" href="../../doc.html#pyny3d.shadows.ShadowsManager.get_sunpos">[docs]</a>    <span class="k">def</span> <span class="nf">get_sunpos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">true_time</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Sun positions for the *t* time vector.</span>
<span class="sd">        </span>
<span class="sd">        *t* have to be in absolute minutes (0 at 00:00 01 Jan). The and </span>
<span class="sd">        in Sun positions calculated are in solar time, that is, maximun </span>
<span class="sd">        solar zenit exactly at midday.</span>
<span class="sd">        </span>
<span class="sd">        The generated information is stored in:</span>
<span class="sd">            * **.azimuth_zenit** (*ndarray*)</span>
<span class="sd">            * **.true_time** (*datetime*): local time</span>
<span class="sd">        </span>
<span class="sd">        :param t: Absolute minutes vector.</span>
<span class="sd">        :type t: ndarray (dtype=int)</span>
<span class="sd">        :param true_time: If True, a datetime vector with the true local</span>
<span class="sd">            time will be stored at ``.true_time``</span>
<span class="sd">        :type true_time: bool</span>
<span class="sd">        :returns: Equivalent times in absolute minutes in year.</span>
<span class="sd">        :rtype: ndarray (dtype=int)</span>
<span class="sd">        </span>
<span class="sd">        :returns: None</span>
<span class="sd">        </span>
<span class="sd">        .. seealso:: :func:`to_minutes` to easily genetare valid input </span>
<span class="sd">            t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_latitude</span>
        <span class="nb">long</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_longitude</span>
        <span class="n">alphamin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_zenitmin</span>
        
        <span class="c1"># Solar calculations</span>
        <span class="n">day</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="mi">1440</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fractional_year</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">365</span><span class="o">*</span><span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">+</span><span class="n">t</span><span class="p">)</span>
        <span class="n">declination</span> <span class="o">=</span> <span class="mf">0.006918</span> <span class="o">-</span> \
                      <span class="mf">0.399912</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fractional_year</span><span class="p">)</span> <span class="o">+</span> \
                      <span class="mf">0.070257</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fractional_year</span><span class="p">)</span> <span class="o">-</span> \
                      <span class="mf">0.006758</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fractional_year</span><span class="p">)</span> <span class="o">+</span> \
                      <span class="mf">0.000907</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fractional_year</span><span class="p">)</span> <span class="o">-</span> \
                      <span class="mf">0.002697</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">fractional_year</span><span class="p">)</span> <span class="o">+</span> \
                      <span class="mf">0.00148</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">fractional_year</span><span class="p">)</span>
        
        <span class="n">hour_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="p">),</span> 
                                       <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">),</span> <span class="mi">365</span><span class="p">)[</span><span class="n">t</span><span class="p">]</span>
        <span class="n">solar_zenit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">declination</span><span class="p">)</span> <span class="o">+</span> \
                      <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">declination</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">hour_angle</span><span class="p">))</span>
        <span class="n">solar_zenit</span><span class="p">[</span><span class="n">solar_zenit</span><span class="o">&lt;=</span><span class="mi">0</span><span class="o">+</span><span class="n">alphamin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1">#### Avoiding numpy warning</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">solar_zenit</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">declination</span><span class="p">))</span><span class="o">/</span> \
              <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">solar_zenit</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span>
        <span class="n">not_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">aux</span><span class="p">))</span>
        <span class="n">aux_1</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="n">not_nan</span><span class="p">]</span>
        <span class="n">aux_1</span><span class="p">[</span><span class="n">aux_1</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">aux</span><span class="p">[</span><span class="n">not_nan</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_1</span>
        <span class="c1">####</span>
        <span class="n">solar_azimuth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>
        <span class="n">solar_azimuth</span><span class="p">[</span><span class="n">day</span><span class="o">==</span><span class="mf">0.5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">solar_azimuth</span><span class="p">[</span><span class="n">day</span><span class="o">&lt;</span><span class="mf">0.5</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_zenit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">solar_azimuth</span><span class="p">,</span> <span class="n">solar_zenit</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                
        <span class="c1"># True time</span>
        <span class="k">if</span> <span class="n">true_time</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">datetime</span> <span class="kn">as</span> <span class="nn">dt</span>
            <span class="nb">long</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="nb">long</span><span class="p">)</span>
            <span class="n">instant_0</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Simulator time </span>
            
            <span class="c1"># Real time</span>
            <span class="n">equation_time</span> <span class="o">=</span> <span class="mf">229.18</span><span class="o">*</span><span class="p">(</span><span class="mf">0.000075</span><span class="o">+</span><span class="mf">0.001868</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fractional_year</span><span class="p">)</span> <span class="o">-</span> \
                            <span class="mf">0.032077</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fractional_year</span><span class="p">)</span> <span class="o">-</span> \
                            <span class="mf">0.014615</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fractional_year</span><span class="p">)</span> <span class="o">-</span> \
                            <span class="mf">0.040849</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fractional_year</span><span class="p">))</span>
        
            <span class="n">time_offset</span> <span class="o">=</span> <span class="n">equation_time</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="nb">long</span> <span class="o">+</span> <span class="mi">60</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_UTC</span>
            <span class="n">true_solar_time</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">time_offset</span>
            <span class="n">delta_true_date_objs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> 
                                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">true_solar_time</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">true_time</span> <span class="o">=</span> <span class="n">instant_0</span> <span class="o">+</span> <span class="n">delta_true_date_objs</span>
        </div>
<div class="viewcode-block" id="ShadowsManager.compute_shadows"><a class="viewcode-back" href="../../doc.html#pyny3d.shadows.ShadowsManager.compute_shadows">[docs]</a>    <span class="k">def</span> <span class="nf">compute_shadows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the ``pyny.Space`` stored in ``.space`` shadowing for</span>
<span class="sd">        the time intervals and Sun positions stored in ``.arg_t`` and</span>
<span class="sd">        ``.sun_pos``, respectively.</span>
<span class="sd">        </span>
<span class="sd">        The generated information is stored in:</span>
<span class="sd">            * **.light** (*ndarray (dtype=bool)*): Array with the points </span>
<span class="sd">                in ``pyny.Space`` as columns and the Sun positions as </span>
<span class="sd">                rows. Indicates whether the points are illuminated in</span>
<span class="sd">                each Sun position.</span>
<span class="sd">        </span>
<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyny3d.utils</span> <span class="kn">import</span> <span class="n">sort_numpy</span><span class="p">,</span> <span class="n">bool2index</span><span class="p">,</span> <span class="n">index2bool</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span>
        
        <span class="n">light</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sun</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vor_centers</span><span class="p">:</span>
            <span class="c1"># Rotation of the whole ``pyny.Space``</span>
            <span class="n">polygons_photo</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">points_to_eval</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">photo</span><span class="p">(</span><span class="n">sun</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="c1"># Auxiliar pyny.Surface to fast management of pip</span>
            <span class="n">Photo_surface</span> <span class="o">=</span> <span class="n">pyny</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span><span class="n">polygons_photo</span><span class="p">,</span> <span class="n">check_convexity</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">Photo_surface</span><span class="o">.</span><span class="n">lock</span><span class="p">()</span>
           
            <span class="c1"># Sort/unsort points</span>
            <span class="n">n_points</span> <span class="o">=</span> <span class="n">points_to_eval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">points_index_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span> <span class="c1"># _N indicates the depth level</span>
            <span class="n">points_to_eval</span><span class="p">,</span> <span class="n">order_back</span> <span class="o">=</span> <span class="n">sort_numpy</span><span class="p">(</span><span class="n">points_to_eval</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                                                    <span class="n">order_back</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c1"># Loop over the sorted (areas) Polygons</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">sorted_areas</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">points_to_eval</span><span class="p">[</span><span class="n">points_index_0</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">polygon_photo</span> <span class="o">=</span> <span class="n">Photo_surface</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">index_1</span> <span class="o">=</span> <span class="n">bool2index</span><span class="p">(</span><span class="n">polygon_photo</span><span class="o">.</span><span class="n">pip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sorted_col</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">points_1</span> <span class="o">=</span> <span class="n">points_to_eval</span><span class="p">[</span><span class="n">points_index_0</span><span class="p">[</span><span class="n">index_1</span><span class="p">]]</span>
                
                <span class="k">if</span> <span class="n">points_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Rotation algebra</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">polygon_photo</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">,</span>  <span class="n">c</span><span class="o">-</span><span class="n">a</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">R_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
                    <span class="n">Tr</span> <span class="o">=</span> <span class="n">a</span> <span class="c1"># Translation</span>
                    <span class="c1"># Reference point (between the Sun and the polygon)</span>
                    <span class="n">reference_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">reference_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reference_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">points_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">points_1</span><span class="p">,</span> <span class="n">reference_point</span><span class="p">))</span>
                    <span class="n">points_over_polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R_inv</span><span class="p">,</span> <span class="p">(</span><span class="n">points_1</span><span class="o">-</span><span class="n">Tr</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="c1"># Logical stuff</span>
                    <span class="n">shadow_bool_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">points_over_polygon</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">!=</span> \
                                    <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">points_over_polygon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>     
                    <span class="n">shadow_index_2</span> <span class="o">=</span> <span class="n">bool2index</span><span class="p">(</span><span class="n">shadow_bool_2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">shadow_index_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">points_to_remove</span> <span class="o">=</span> <span class="n">index_1</span><span class="p">[</span><span class="n">shadow_index_2</span><span class="p">]</span>
                        <span class="n">points_index_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">points_index_0</span><span class="p">,</span> 
                                                   <span class="n">points_to_remove</span><span class="p">)</span>
            
            <span class="n">lighted_bool_0</span> <span class="o">=</span> <span class="n">index2bool</span><span class="p">(</span><span class="n">points_index_0</span><span class="p">,</span> 
                                        <span class="n">length</span><span class="o">=</span><span class="n">points_to_eval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Updating the solution</span>
            <span class="n">light</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lighted_bool_0</span><span class="p">[</span><span class="n">order_back</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">light</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">light</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="ShadowsManager.project_data"><a class="viewcode-back" href="../../doc.html#pyny3d.shadows.ShadowsManager.project_data">[docs]</a>    <span class="k">def</span> <span class="nf">project_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Assign the sum of ``integral``\* to each sensible</span>
<span class="sd">        point in the ``pyny.Space`` for the intervals that the points</span>
<span class="sd">        are visible to the Sun.</span>

<span class="sd">        The generated information is stored in:</span>
<span class="sd">            * **.proj_vor** (*ndarray*): ``.integral`` projected to the </span>
<span class="sd">                Voronoi diagram.</span>
<span class="sd">            * **.proj_points** (*ndarray*): ``.integral`` projected to </span>
<span class="sd">                the sensible points in the ``pyny.Space``.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        </span>
<span class="sd">        .. note:: \* ``integral = np.diff(t)*data``</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">pyny3d.utils</span> <span class="kn">import</span> <span class="n">sort_numpy</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">light</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="n">map_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">t2vor_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">map_sorted</span> <span class="o">=</span> <span class="n">sort_numpy</span><span class="p">(</span><span class="n">map_</span><span class="p">)</span>
        
        <span class="n">n_points</span> <span class="o">=</span> <span class="n">map_sorted</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">map_sorted</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>           
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">n_points</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">proj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">map_sorted</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_vor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        </div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="ShadowsManager.to_minutes"><a class="viewcode-back" href="../../doc.html#pyny3d.shadows.ShadowsManager.to_minutes">[docs]</a>    <span class="k">def</span> <span class="nf">to_minutes</span><span class="p">(</span><span class="n">time_obj</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Converts ``datetime`` objects lists into absolute minutes </span>
<span class="sd">        vectors. It also can be used to generate absolute minutes vector</span>
<span class="sd">        from a time interval (in minutes).</span>
<span class="sd">        </span>
<span class="sd">        :param time_obj: ``datetime`` objects to convert into absolute </span>
<span class="sd">            minutes.</span>
<span class="sd">        :type time_obj: list of ``datetime`` objects</span>
<span class="sd">        :param dt: Constant interval time to generate a time vector for</span>
<span class="sd">            a whole year.</span>
<span class="sd">        :type dt: int</span>
<span class="sd">        :returns: Equivalent times in absolute minutes in year.</span>
<span class="sd">        :rtype: ndarray (dtype=int)</span>
<span class="sd">        </span>
<span class="sd">        .. note:: If the time_obj has times higher than 23:59 31 Dec, </span>
<span class="sd">            they will be removed.</span>
<span class="sd">        .. note:: If a leap-year is introduced, the method will remove</span>
<span class="sd">            the last year (31 Dec) in order to keep the series </span>
<span class="sd">            continuous.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">datetime</span>

        <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">time_obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">365</span><span class="o">*</span><span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">dt</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">time_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">time_obj</span><span class="p">)</span> <span class="o">==</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">:</span> 
                <span class="n">time_obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_obj</span><span class="p">]</span>
            
            <span class="n">year</span> <span class="o">=</span> <span class="n">time_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">year</span>
            <span class="n">time</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">time_obj</span><span class="p">:</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">year</span> <span class="o">==</span> <span class="n">tt</span><span class="o">.</span><span class="n">tm_year</span><span class="p">:</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tt</span><span class="o">.</span><span class="n">tm_yday</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">24</span><span class="o">*</span><span class="mi">60</span> <span class="o">+</span>
                                 <span class="n">tt</span><span class="o">.</span><span class="n">tm_hour</span><span class="o">*</span><span class="mi">60</span> <span class="o">+</span>
                                 <span class="n">tt</span><span class="o">.</span><span class="n">tm_min</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input error&#39;</span><span class="p">)</span>
        
    </div></div>
<div class="viewcode-block" id="Viz"><a class="viewcode-back" href="../../doc.html#pyny3d.shadows.Viz">[docs]</a><span class="k">class</span> <span class="nc">Viz</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This class stores the visualization methods. It is linked with </span>
<span class="sd">    the ShadowsManager class by its attribute ``.viz``.</span>
<span class="sd">    </span>
<span class="sd">    :param ShadowsMaganer: ShadowsMaganer instance to compute the </span>
<span class="sd">        visualizations.</span>
<span class="sd">    :returns: None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ShadowsMaganer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SM</span> <span class="o">=</span> <span class="n">ShadowsMaganer</span>
        
<div class="viewcode-block" id="Viz.vor_plot"><a class="viewcode-back" href="../../doc.html#pyny3d.shadows.Viz.vor_plot">[docs]</a>    <span class="k">def</span> <span class="nf">vor_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;vor&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Voronoi diagram visualizations. There are three types:</span>
<span class="sd">        </span>
<span class="sd">            1. **vor**: Voronoi diagram of the Solar Horizont.</span>
<span class="sd">            2. **freq**: Frequency of Sun positions in t in the Voronoi</span>
<span class="sd">                diagram of the Solar Horizont.</span>
<span class="sd">            3. **data**: Accumulated time integral of the data projected </span>
<span class="sd">                in the Voronoi diagram of the Solar Horizont.</span>
<span class="sd">        </span>
<span class="sd">        :param which: Type of visualization.</span>
<span class="sd">        :type which: str</span>
<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="kn">as</span> <span class="nn">cm</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="n">sm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SM</span>
        <span class="k">if</span> <span class="n">sm</span><span class="o">.</span><span class="n">light</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The computation has not been made yet&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">which</span> <span class="ow">is</span> <span class="s1">&#39;vor&#39;</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Voronoi diagram of the Solar Horizont&#39;</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">vor_surf</span><span class="o">.</span><span class="n">plot2d</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">azimuth_zenit</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span><span class="n">sm</span><span class="o">.</span><span class="n">azimuth_zenit</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">vor_centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sm</span><span class="o">.</span><span class="n">vor_centers</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Solar Azimuth&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Solar Zenit&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">which</span> <span class="ow">is</span> <span class="s1">&#39;freq&#39;</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">Blues</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Frequency of Sun positions in the Voronoi diagram &#39;</span><span class="o">+</span>\
                     <span class="s1">&#39;of the Solar Horizont&#39;</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">vor_surf</span><span class="o">.</span><span class="n">plot2d</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">vor_freq</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.85</span><span class="p">,</span> 
                                    <span class="n">colorbar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                    <span class="n">cbar_label</span><span class="o">=</span><span class="s1">&#39;    Freq&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Solar Azimuth&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Solar Zenit&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            
        <span class="k">elif</span> <span class="n">which</span> <span class="ow">is</span> <span class="s1">&#39;data&#39;</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">YlOrRd</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Data projected in the Voronoi diagram of the&#39;</span><span class="o">+</span>\
                    <span class="s1">&#39; Solar Horizont&#39;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">proj_vor</span><span class="o">/</span><span class="n">sm</span><span class="o">.</span><span class="n">vor_freq</span>
            <span class="n">proj_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">vor_surf</span><span class="o">.</span><span class="n">plot2d</span><span class="p">(</span><span class="n">proj_data</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.85</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                                    <span class="n">colorbar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                    <span class="n">cbar_label</span><span class="o">=</span><span class="s1">&#39;%&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Solar Azimuth&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Solar Zenit&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;max = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="o">+</span><span class="s1">&#39; kilounits*hour&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid plot &#39;</span><span class="o">+</span><span class="n">which</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="Viz.exposure_plot"><a class="viewcode-back" href="../../doc.html#pyny3d.shadows.Viz.exposure_plot">[docs]</a>    <span class="k">def</span> <span class="nf">exposure_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">places</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_poly</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">c_holes</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span>
                      <span class="n">s_sop</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">extra_height</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the exposure of the sensible points in a space to the data</span>
<span class="sd">        and the Sun positions. It is required to previously compute the </span>
<span class="sd">        shadowing.</span>
<span class="sd">        </span>
<span class="sd">        If the computation has been made with a data timeseries, the plot</span>
<span class="sd">        will have a colorbar. Units are accumulated kilounits*hour (for </span>
<span class="sd">        the series), that is, if the input data is in Watts </span>
<span class="sd">        (irradiation) for a whole year, the output will be </span>
<span class="sd">        kWh received in an entire year.</span>
<span class="sd">        </span>
<span class="sd">        If there is no data inputed, the plot will show only the number</span>
<span class="sd">        of times each point &quot;has been seen by the Sun&quot; along the series.</span>
<span class="sd">        </span>
<span class="sd">        :param places: Indexes of the places to plot. If -1, plots all.</span>
<span class="sd">        :type places: int or list</span>
<span class="sd">        :param c_poly: Polygons color.</span>
<span class="sd">        :type c_poly: matplotlib color, &#39;default&#39; or &#39;t&#39; (transparent)</span>
<span class="sd">        :param c_holes: Holes color.</span>
<span class="sd">        :type c_holes: matplotlib color, &#39;default&#39; or &#39;t&#39; (transparent)</span>
<span class="sd">        :param s_sop: Set of points size.</span>
<span class="sd">        :type s_sop: float or ndarray</span>
<span class="sd">        :param extra_height: Extra elevation for the points in the plot.</span>
<span class="sd">        :type extra_height: float</span>
<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="kn">as</span> <span class="nn">cm</span>
        <span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="kn">as</span> <span class="nn">mcolors</span>

        <span class="n">sm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SM</span>
        <span class="k">if</span> <span class="n">sm</span><span class="o">.</span><span class="n">light</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The shadowing has not been computed yet&#39;</span><span class="p">)</span>
        <span class="n">proj_data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">proj_points</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">sm</span><span class="o">.</span><span class="n">proj_points</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">places</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> 
            <span class="n">places</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">places</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">places</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">places</span> <span class="o">=</span> <span class="p">[</span><span class="n">places</span><span class="p">]</span>
            
        <span class="n">places</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">places</span><span class="p">)</span>
        <span class="n">places</span><span class="p">[</span><span class="n">places</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">places</span><span class="p">)</span> <span class="o">+</span> <span class="n">places</span><span class="p">[</span><span class="n">places</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">places</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">places</span><span class="p">)</span>
        
        <span class="n">points</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">get_sets_of_points</span><span class="p">()</span>        
        <span class="n">index</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">get_sets_index</span><span class="p">()</span>        
        
        <span class="c1"># Model plot</span>
        <span class="n">sop</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">aux_space</span> <span class="o">=</span> <span class="n">pyny</span><span class="o">.</span><span class="n">Space</span><span class="p">()</span> <span class="c1"># Later centering of the plot</span>
        <span class="n">ax</span><span class="o">=</span><span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">places</span><span class="p">:</span>
            <span class="n">aux_space</span><span class="o">.</span><span class="n">add_places</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">space</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">space</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">iplot</span><span class="p">(</span><span class="n">c_poly</span><span class="o">=</span><span class="n">c_poly</span><span class="p">,</span> <span class="n">c_holes</span><span class="o">=</span><span class="n">c_holes</span><span class="p">,</span> 
                                   <span class="n">c_sop</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">sop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">index</span><span class="o">==</span><span class="n">i</span><span class="p">])</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proj_data</span><span class="p">[</span><span class="n">index</span><span class="o">==</span><span class="n">i</span><span class="p">])</span>
        <span class="n">sop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">sop</span><span class="p">)</span>
        <span class="n">sop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sop</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1e+12</span><span class="p">,</span> <span class="o">-</span><span class="mf">1e+12</span><span class="p">,</span> <span class="o">-</span><span class="mf">1e+12</span><span class="p">])))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">proj_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                              
        <span class="c1"># Sensible points plot</span>
        <span class="c1">## Color</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">jet</span>
        <span class="n">normalize</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">proj_data</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> 
                                      <span class="n">vmax</span><span class="o">=</span><span class="n">proj_data</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">color_vector</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">proj_data</span><span class="p">))</span>
        <span class="c1">## Plot</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">sop</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sop</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sop</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">extra_height</span><span class="p">,</span> 
                   <span class="n">c</span><span class="o">=</span><span class="n">color_vector</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s_sop</span><span class="p">)</span>
        <span class="c1">## Axis</span>
        <span class="n">aux_space</span><span class="o">.</span><span class="n">center_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                   
        <span class="c1">## Colorbar</span>
        <span class="n">scalarmappaple</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">scalarmappaple</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">proj_data</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scalarmappaple</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">arg_data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sm</span><span class="o">.</span><span class="n">arg_data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Accumulated data Projection</span><span class="se">\n</span><span class="s1">max = &#39;</span> <span class="o">+</span> \
                      <span class="nb">str</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">proj_points</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">+</span> \
                      <span class="s1">&#39; kilounits*hour&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Sun exposure&#39;</span><span class="p">)</span>
        
        
    </div></div>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Josรฉ Antonio Fernรกndez-Fernรกndez.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>