<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyny3d.geoms &mdash; pyny3d 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyny3d 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>pyny3d 0.1 documentation</span></a></h1>
        <h2 class="heading"><span>pyny3d.geoms</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for pyny3d.geoms</h1><div class="highlight"><pre>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<div class="viewcode-block" id="root"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.root">[docs]</a><span class="k">class</span> <span class="nc">root</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lowest geometry class in hierarchy. Actually do nothig but store</span>
<span class="sd">    two general methods for the real classes:</span>
<span class="sd">    </span>
<span class="sd">        * :func:`plot`</span>
<span class="sd">        * :func:`get_centroid`</span>
<span class="sd">        * :func:`copy`</span>
<span class="sd">        * :func:`save`</span>
<span class="sd">        * :func:`restore`</span>
<span class="sd">    </span>
<span class="sd">    Other Global methods (but individually defined in each class) are:</span>
<span class="sd">    </span>
<span class="sd">        * get_seed</span>
<span class="sd">        * seed2pyny</span>
<span class="sd">        * get_domain</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backup</span> <span class="o">=</span> <span class="bp">None</span>
    
<div class="viewcode-block" id="root.plot"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.root.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a 3D visualization.</span>
<span class="sd">  </span>
<span class="sd">        :param color: Polygons color.</span>
<span class="sd">        :param ret: If True, returns the figure. It can be used to add </span>
<span class="sd">            more elements to the plot or to modify it.</span>
<span class="sd">        :param ax: This plot will be represented </span>
<span class="sd">            on top. This is used to represent multiple plots from </span>
<span class="sd">            multiple geometries, overlapping them recursively.</span>
<span class="sd">        :type color: matplotlib color, &#39;default&#39; or &#39;t&#39; (transparent)</span>
<span class="sd">        :type ret: bool</span>
<span class="sd">        :type ax: mplot3d.Axes3D, None</span>
<span class="sd">        :returns: None, axes</span>
<span class="sd">        :rtype: mplot3d.Axes3D, bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">as</span> <span class="nn">mplot3d</span>
        
        <span class="c1"># Bypass a plot</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">mplot3d</span><span class="o">.</span><span class="n">Axes3D</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">ax</span>
        
        <span class="c1"># Clone and extract the information from the object</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">get_seed</span><span class="p">())</span>
        <span class="n">plotable3d</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_plotable3d</span><span class="p">()</span>
            
        <span class="c1"># Domain</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_centroid</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">centroid</span><span class="o">-</span><span class="n">bound</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">centroid</span><span class="o">+</span><span class="n">bound</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        
        <span class="c1"># Cascade plot?</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c1"># Non cascade</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">mplot3d</span><span class="o">.</span><span class="n">Axes3D</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">old_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xbound</span><span class="p">(),</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">get_ybound</span><span class="p">(),</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">get_zbound</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">old_pos</span><span class="p">))</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)])</span>
            
        <span class="c1"># Plot</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">plotable3d</span><span class="p">:</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_collection3d</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
        
        <span class="c1"># Axis limits</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim3d</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim3d</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">top</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim3d</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">top</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span> <span class="k">return</span> <span class="n">ax</span>
            </div>
<div class="viewcode-block" id="root.center_plot"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.root.center_plot">[docs]</a>    <span class="k">def</span> <span class="nf">center_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Centers and keep the aspect ratio in a 3D representation.</span>
<span class="sd">        </span>
<span class="sd">        Created to help higher classes to manage cascade representation</span>
<span class="sd">        of multiple lower objects.</span>
<span class="sd">        </span>
<span class="sd">        :param ax: Axes to apply the method.</span>
<span class="sd">        :type ax: mplot3d.Axes3D</span>
<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Domain</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_centroid</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">centroid</span><span class="o">-</span><span class="n">bound</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">centroid</span><span class="o">+</span><span class="n">bound</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Axis limits</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim3d</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim3d</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">top</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlim3d</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">top</span><span class="o">=</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="root.get_centroid"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.root.get_centroid">[docs]</a>    <span class="k">def</span> <span class="nf">get_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The centroid is considered the center point of the circunscribed</span>
<span class="sd">        paralellepiped, not the mass center.</span>
<span class="sd">        </span>
<span class="sd">        :returns: (x, y, z) coordinates of the centroid of the object.</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="root.copy"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.root.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: A deepcopy the entire instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_seed</span><span class="p">()))</span>
        </div>
<div class="viewcode-block" id="root.save"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.root.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves a deepcopy of the current state the instance. </span>
<span class="sd">        ``.restore()`` method will return this copy.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="root.restore"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.root.restore">[docs]</a>    <span class="k">def</span> <span class="nf">restore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a previous saved state of the current object. ``.save()``</span>
<span class="sd">        method can be used any time to save the current state of an </span>
<span class="sd">        object.</span>
<span class="sd">        </span>
<span class="sd">        :returns: Restored version of this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backup</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No backup previously saved.&#39;</span><span class="p">)</span>

        </div></div>
<div class="viewcode-block" id="Polygon"><a class="viewcode-back" href="../../tutorial_polygon.html#pyny3d.geoms.Polygon">[docs]</a><span class="k">class</span> <span class="nc">Polygon</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic geometry object. It generates and stores all the information</span>
<span class="sd">    relative to a polygon in 3D.</span>
<span class="sd">    </span>
<span class="sd">    Instances of this class work as iterable object. When indexed, </span>
<span class="sd">    returns the points which conform it.</span>
<span class="sd">    </span>
<span class="sd">    :param points: np.array with the sorted points which form the </span>
<span class="sd">        polygon (xyz or xy). Do not repeat the first point at the end.</span>
<span class="sd">    :type points: ndarray *shape=(N, 2 or 3)*</span>
<span class="sd">    :param make_ccw: If True, points will be sorted ccw.</span>
<span class="sd">    :type make_ccw: bool</span>
<span class="sd">    :returns: None</span>
<span class="sd">  </span>
<span class="sd">    .. note:: This object can be locked (``.lock()`` method) in order to </span>
<span class="sd">        precompute the domain and the path for faster further </span>
<span class="sd">        computations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">verify</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">make_ccw</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="c1"># Input errors</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pyny3d.Polygon needs a ndarray as input&#39;</span><span class="p">)</span>
                
        <span class="c1"># Adapt 2D/3D</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyny3d.utils</span> <span class="kn">import</span> <span class="n">arange_col</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">points</span><span class="p">,</span> <span class="n">arange_col</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pyny3d.Polygon needs 2 or 3 coords &#39;</span><span class="o">+</span>\
                             <span class="s1">&#39;(columns) at least&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">make_ccw</span> <span class="ow">and</span> <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span><span class="p">:</span> <span class="n">points</span> <span class="o">=</span> <span class="n">Polygon</span><span class="o">.</span><span class="n">make_ccw</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># Basic processing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>
        
        <span class="c1"># Optional processing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parametric</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shapely</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c1"># Parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locked</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="bp">None</span>
                
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        
<div class="viewcode-block" id="Polygon.lock"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.lock">[docs]</a>    <span class="k">def</span> <span class="nf">lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Precomputes some parameters to run faster specific methods like</span>
<span class="sd">        Surface.classify.</span>

<span class="sd">        Stores ``self.domain`` and ``self.path``, both very used in</span>
<span class="sd">        the shadows simulation, in order to avoid unnecesssary</span>
<span class="sd">        calculations.</span>
<span class="sd">        </span>
<span class="sd">        Once locked, it is possible to retrieve the domain and the path</span>
<span class="sd">        of a polygon by ``self.domain`` and ``self.path`` instead </span>
<span class="sd">        launching ``self.get_path()`` and ``self.get_domain()``.</span>
<span class="sd">        </span>
<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">locked</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locked</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Polygon.seed2pyny"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.seed2pyny">[docs]</a>    <span class="k">def</span> <span class="nf">seed2pyny</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-initialize an object with a seed.</span>
<span class="sd">        </span>
<span class="sd">        :returns: A new ``pyny.Polygon``</span>
<span class="sd">        :rtype: ``pyny.Polygon``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># import geoms as pyny</span>
        <span class="k">return</span> <span class="n">Polygon</span><span class="p">(</span><span class="o">**</span><span class="n">seed</span><span class="p">)</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Polygon.is_convex"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.is_convex">[docs]</a>    <span class="k">def</span> <span class="nf">is_convex</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Static method. Returns True if the polygon is convex regardless </span>
<span class="sd">        of whether its vertices follow a clockwise or a </span>
<span class="sd">        counter-clockwise order. This is a requirement for the rest of </span>
<span class="sd">        the program.</span>
<span class="sd">        </span>
<span class="sd">        :param points: Polygons color.</span>
<span class="sd">        :type points: ndarray with points (xyz or xy) in rows</span>
<span class="sd">        :returns: Whether a polygon is convex or not.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        </span>
<span class="sd">        .. note:: Despite the code works for ccw polygons, in order to </span>
<span class="sd">            avoid possible bugs it is always recommended to use ccw </span>
<span class="sd">            rather than cw.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Verification based on the cross product</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)))</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_points</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">s</span> <span class="o">-</span> <span class="n">last</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">s</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Polygon.make_ccw"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.make_ccw">[docs]</a>    <span class="k">def</span> <span class="nf">make_ccw</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Static method. Returns a counterclock wise ordered sequence of </span>
<span class="sd">        points based on its z=0 projection. If there are any repeated</span>
<span class="sd">        point the method will raise an error.</span>
<span class="sd">        </span>
<span class="sd">        :param points: Points to form a polygon (xyz or xy)</span>
<span class="sd">        :type points: ndarray with points (xyz or xy) in rows</span>
<span class="sd">        :returns: ccw version of the points.</span>
<span class="sd">        :rtype: ndarray (shape=(N, 2 or 3))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>
        <span class="kn">from</span> <span class="nn">pyny3d.utils</span> <span class="kn">import</span> <span class="n">sort_numpy</span>
        
        <span class="c1"># Repeated points</span>
        <span class="n">points_aux</span> <span class="o">=</span> <span class="n">sort_numpy</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">points_aux</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Repeated point: </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        
        <span class="c1"># Convexity</span>
        <span class="c1">## If there is no convex Polygon in any projection, the Polygon</span>
        <span class="c1"># is wrong</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">cols</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="n">cols</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">hull</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong polygon: </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="n">hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Polygon.to_2d"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.to_2d">[docs]</a>    <span class="k">def</span> <span class="nf">to_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the real 2D polygon of the 3D polygon.</span>
<span class="sd">        </span>
<span class="sd">        This library mostly uses the z=0 projection to perform </span>
<span class="sd">        operations with the polygons. For this reason, if real 2D</span>
<span class="sd">        planar operations are required (draw a real matplotlib.path, </span>
<span class="sd">        calculate real area...) the best way is to create a new </span>
<span class="sd">        ``pyny.Polygon`` with this method.</span>
<span class="sd">        </span>
<span class="sd">        :returns: Planar orthogonal view of the polygon.</span>
<span class="sd">        :rtype: ``pyny.Polygon``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Normal</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        
        <span class="n">R_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R_inv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">real</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">return</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">real</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="Polygon.contains"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Point-in-Polygon for the z=0 projection.</span>
<span class="sd">        </span>
<span class="sd">        :param points: Set of points to evaluate.</span>
<span class="sd">        :type points: ndarray with points (xyz or xy) in rows</span>
<span class="sd">        :param edge: If True, consider the points in the Polygon&#39;s edge</span>
<span class="sd">            inside the Polygon.</span>
<span class="sd">        :type edge: bool</span>
<span class="sd">        :returns: Whether each point is inside the polygon or not (in</span>
<span class="sd">            z=0 projection).</span>
<span class="sd">        :rtype: ndarray (dtype=bool)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="mf">1e-10</span> <span class="k">if</span> <span class="n">edge</span> <span class="k">else</span> <span class="o">-</span><span class="mf">1e-10</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span>
                                               <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Polygon.get_parametric"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.get_parametric">[docs]</a>    <span class="k">def</span> <span class="nf">get_parametric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the parametric equation of the plane that contains </span>
<span class="sd">        the polygon. The output has the form np.array([a, b, c, d]) </span>
<span class="sd">        for:</span>

<span class="sd">        .. math::</span>
<span class="sd">            a*x + b*y + c*z + d = 0</span>
<span class="sd">        </span>
<span class="sd">        :param check: Checks whether the points are actually</span>
<span class="sd">            in the same plane with certain *tolerance*.</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :param tolerance: Tolerance to check whether the points belong</span>
<span class="sd">            to the same plane.</span>
<span class="sd">        :type tolerance: float</span>
<span class="sd">        </span>
<span class="sd">        .. note:: This method automatically stores the solution in order</span>
<span class="sd">            to do not repeat calculations if the user needs to call it </span>
<span class="sd">            more than once.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parametric</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> 
            
            <span class="c1"># Plane calculation</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
            <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parametric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
                
            <span class="c1"># Point belonging verification</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="o">+</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="o">+</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">c</span><span class="o">+</span>
                                     <span class="n">d</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Polygon not plane: </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span>\
                                         <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parametric</span>
        </div>
<div class="viewcode-block" id="Polygon.get_path"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.get_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: matplotlib.path.Path object for the z=0 projection of </span>
<span class="sd">            this polygon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># z=0 projection!</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>
        </div>
<div class="viewcode-block" id="Polygon.get_shapely"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.get_shapely">[docs]</a>    <span class="k">def</span> <span class="nf">get_shapely</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: shapely.Polygon object of the z=0 projection of </span>
<span class="sd">            this polygon.</span>
<span class="sd">        </span>
<span class="sd">        .. note:: This method automatically stores the solution in order</span>
<span class="sd">            to do not repeat calculations if the user needs to call it </span>
<span class="sd">            more than once.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapely</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span> <span class="k">as</span> <span class="n">shPolygon</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shapely</span> <span class="o">=</span> <span class="n">shPolygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># z=0 projection!</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapely</span>
            </div>
<div class="viewcode-block" id="Polygon.get_domain"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.get_domain">[docs]</a>    <span class="k">def</span> <span class="nf">get_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: opposite vertices of the bounding prism for this </span>
<span class="sd">            object.</span>
<span class="sd">        :rtype: ndarray([min], [max])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> 
                             <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>
</div>
<div class="viewcode-block" id="Polygon.get_area"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.get_area">[docs]</a>    <span class="k">def</span> <span class="nf">get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The area of the polygon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_2d</span><span class="p">()</span><span class="o">.</span><span class="n">get_shapely</span><span class="p">()</span><span class="o">.</span><span class="n">area</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span>
</div>
<div class="viewcode-block" id="Polygon.get_height"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.get_height">[docs]</a>    <span class="k">def</span> <span class="nf">get_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">only_in</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a set of points, computes the z value for the parametric</span>
<span class="sd">        equation of the plane where the polygon belongs.</span>
<span class="sd">        </span>
<span class="sd">        Only the two first columns of the points will be taken into </span>
<span class="sd">        account as x and y.</span>
<span class="sd">        </span>
<span class="sd">        The points outside the object will have a NaN value in the</span>
<span class="sd">        z column. If the inputed points has a third column the z values</span>
<span class="sd">        outside the Surface&#39;s domain will remain unchanged, the rest</span>
<span class="sd">        will be replaced.</span>
<span class="sd">        </span>
<span class="sd">        :param points: list of coordinates of the points to calculate.</span>
<span class="sd">        :type points: ndarray shape=(N, 2 or 3)</span>
<span class="sd">        :param only_in: returns only the points which are inside of the</span>
<span class="sd">            Polygon.</span>
<span class="sd">        :type only_in: bool</span>
<span class="sd">        :param edge: If True, consider the points in the Polygon&#39;s edge</span>
<span class="sd">            inside the Polygon.</span>
<span class="sd">        :type edge: bool</span>
<span class="sd">        :param full: If true, the return will have three columns </span>
<span class="sd">            (x, y, z) instead of one (z).</span>
<span class="sd">        :type full: bool</span>
<span class="sd">        :returns: (z) or (x, y, z)</span>
<span class="sd">        :rtype: ndarray shape=(N, 1 or 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parametric</span><span class="p">()</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">only_in</span><span class="p">:</span>
            <span class="n">pip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">edge</span><span class="p">)</span>
            <span class="n">z</span><span class="p">[</span><span class="n">pip</span> <span class="o">==</span> <span class="bp">False</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            
        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> 
                           <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># Restore original z</span>
                <span class="n">z</span><span class="p">[</span><span class="n">pip</span> <span class="o">==</span> <span class="bp">False</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">pip</span> <span class="o">==</span> <span class="bp">False</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">z</span>
            </div>
<div class="viewcode-block" id="Polygon.get_seed"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.get_seed">[docs]</a>    <span class="k">def</span> <span class="nf">get_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect the required information to generate a data estructure </span>
<span class="sd">        that can be used to recreate exactly the same Geometry object</span>
<span class="sd">        via *\*\*kwargs*.</span>
<span class="sd">        </span>
<span class="sd">        :returns: Object&#39;s sufficient info to initialize it.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">}</span>
</div>
<div class="viewcode-block" id="Polygon.get_plotable3d"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.get_plotable3d">[docs]</a>    <span class="k">def</span> <span class="nf">get_plotable3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: matplotlib Poly3DCollection</span>
<span class="sd">        :rtype: mpl_toolkits.mplot3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">as</span> <span class="nn">mplot3d</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mplot3d</span><span class="o">.</span><span class="n">art3d</span><span class="o">.</span><span class="n">Poly3DCollection</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">])]</span>
        </div>
<div class="viewcode-block" id="Polygon.pip"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.pip">[docs]</a>    <span class="k">def</span> <span class="nf">pip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">sorted_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Point-in-Polygon for the z=0 projection. This function enhances</span>
<span class="sd">        the performance of ``Polygon.contains()`` by verifying only the </span>
<span class="sd">        points which are inside the bounding box of the polygon. To do </span>
<span class="sd">        it fast, it needs the points array to be already sorted by one</span>
<span class="sd">        column.</span>
<span class="sd">        </span>
<span class="sd">        :param points: list of *(x, y, z) or (x, y)* coordinates of the</span>
<span class="sd">            points to check. (The z value will not be taken into </span>
<span class="sd">            account).</span>
<span class="sd">        :type points: ndarray (shape=(N, 2 or 3))</span>
<span class="sd">        :param sorted_col: Index of the sorted column (0 or 1).</span>
<span class="sd">        :type sorted_col: int</span>
<span class="sd">        :param radius: Enlarge Polygons domain by a specified quantity.</span>
<span class="sd">        :type radius: float</span>
<span class="sd">        :returns: Which points are inside the polygon.</span>
<span class="sd">        :rtype: ndarray (dtpye=bool)</span>
<span class="sd">        </span>
<span class="sd">        .. warning:: By default pip considers that the set of points is</span>
<span class="sd">            currently sorted by the first column.</span>
<span class="sd">        .. warning:: This method only works if the polygon has been </span>
<span class="sd">            locked (:func:`lock`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">radius</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">radius</span>
        
        <span class="c1"># Slicing the sorted column</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">sorted_col</span><span class="p">],</span>
                            <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sorted_col</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">sorted_col</span><span class="p">]</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">))</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        
        <span class="c1"># solution</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)]</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                
        <span class="k">return</span> <span class="n">sol</span>
        </div>
<div class="viewcode-block" id="Polygon.plot2d"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.plot2d">[docs]</a>    <span class="k">def</span> <span class="nf">plot2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a 2D plot for the z=0 Polygon projection.</span>
<span class="sd">        </span>
<span class="sd">        :param color: Polygon color.</span>
<span class="sd">        :type color: matplotlib color</span>
<span class="sd">        :param alpha: Opacity.</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        :param ret: If True, returns the figure. It can be used to add </span>
<span class="sd">            more elements to the plot or to modify it.</span>
<span class="sd">        :type ret: bool</span>
<span class="sd">        :returns: None, axes</span>
<span class="sd">        :rtype: None, matplotlib axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="kn">as</span> <span class="nn">patches</span>
        
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>

        <span class="c1"># Plot</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">patches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                       <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span> <span class="k">return</span> <span class="n">ax</span>
</div>
<div class="viewcode-block" id="Polygon.move"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_xyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate the Polygons in x, y and z coordinates.</span>
<span class="sd">        </span>
<span class="sd">        :param d_xyz: displacement in x, y(, and z).</span>
<span class="sd">        :type d_xyz: tuple (len=2 or 3)</span>
<span class="sd">        :returns: ``pyny.Polygon``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="n">Surface</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">d_xyz</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">surface</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Polygon.zrotate"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.zrotate">[docs]</a>    <span class="k">def</span> <span class="nf">zrotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Polygon which is the same but rotated about a </span>
<span class="sd">        vertical axis.</span>
<span class="sd">        </span>
<span class="sd">        If the axis given is ``None``, the rotation will be computed</span>
<span class="sd">        about the Surface&#39;s centroid.</span>
<span class="sd">        </span>
<span class="sd">        :param angle: Rotation angle (in radians)</span>
<span class="sd">        :type angle: float</span>
<span class="sd">        :param axis: Point in z=0 to perform as rotation axis</span>
<span class="sd">        :type axis: tuple (len=2 or 3) or None</span>
<span class="sd">        :returns: ``pyny.Polygon``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="n">Surface</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">zrotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">surface</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        </div>
<div class="viewcode-block" id="Polygon.mirror"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a symmetry of the Polygon respect global axes.</span>
<span class="sd">        </span>
<span class="sd">        :param axes: &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;xy&#39;, &#39;xz&#39;, &#39;yz&#39;...</span>
<span class="sd">        :type axes: str</span>
<span class="sd">        :returns: ``pyny.Polygon``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="n">Surface</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">surface</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Polygon.matrix"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polygon.matrix">[docs]</a>    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the ``pyny.Polygon`` itself along a 3D matrix given by the </span>
<span class="sd">        three tuples x, y, z:        </span>

<span class="sd">        :param x: Number of copies and distance between them in this</span>
<span class="sd">            direction.</span>
<span class="sd">        :type x: tuple (len=2)</span>
<span class="sd">        :returns: list of ``pyny.Polygons``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="n">Surface</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">place</span><span class="o">.</span><span class="n">surface</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="n">space</span><span class="p">]</span>

        </div></div>
<div class="viewcode-block" id="Surface"><a class="viewcode-back" href="../../tutorial_surface.html#pyny3d.geoms.Surface">[docs]</a><span class="k">class</span> <span class="nc">Surface</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class groups contiguous polygons (coplanars or not). These</span>
<span class="sd">    polygons cannot overlap each other on the z=0 projection.\*</span>
<span class="sd">    </span>
<span class="sd">    This object is a composition of polygons and holes. The polygons can</span>
<span class="sd">    be used to &quot;hold up&quot; other objects (points, other polygons...) and</span>
<span class="sd">    to compute shadows. The holes exist only to prevent the program </span>
<span class="sd">    to place objects on them. The shadows computation do not take care</span>
<span class="sd">    of the holes\*\*, instead, they can be emulated by a collection of </span>
<span class="sd">    polygons.</span>
<span class="sd">    </span>
<span class="sd">    Instances of this class work as iterable object. When indexed, </span>
<span class="sd">    returns the ``pyny.Polygons`` which conform it.</span>

<span class="sd">    :param polygons: Polygons to be set as Surface. This is the only</span>
<span class="sd">        necessary input to create a Surface.</span>
<span class="sd">    :type polygons: list of ndarray, list of ``pyny.Polygon``</span>
<span class="sd">    :param holes: Polygons to be set as holes of the Surface.</span>
<span class="sd">    :type holes: list of ndarray, list of ``pyny.Polygon``</span>
<span class="sd">    :param make_ccw: If True, points will be sorted ccw for each </span>
<span class="sd">        polygon.</span>
<span class="sd">    :type make_ccw: bool</span>
<span class="sd">    :param melt: If True, the :func:`melt` method will be launched at</span>
<span class="sd">        initialization.</span>
<span class="sd">    :type melt: bool</span>
<span class="sd">    :param check_contiguity: If True, :func:`contiguous` will be </span>
<span class="sd">        launched at initialization.</span>
<span class="sd">    :type check_contiguity: bool</span>
<span class="sd">    </span>
<span class="sd">    :returns: None</span>
<span class="sd">    </span>
<span class="sd">    .. note:: \* For models with planes stacked in column, use</span>
<span class="sd">        the Place class to distinct them. For example, a three-storey </span>
<span class="sd">        building structure can be modeled by using one ``pyny.Place`` </span>
<span class="sd">        for storey where the floor is a Surface and the columns are </span>
<span class="sd">        Polyhedra.</span>
<span class="sd">    .. note:: \*\* In the future versions of this library it will </span>
<span class="sd">        simulate shadows through the holes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="p">[],</span> <span class="n">make_ccw</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> 
                 <span class="n">melt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">check_contiguity</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Always works with lists</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">polygons</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span> <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">polygons</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">holes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span> <span class="n">holes</span> <span class="o">=</span> <span class="p">[</span><span class="n">holes</span><span class="p">]</span>
        
        <span class="c1"># Creating the object</span>
        <span class="c1">## Polygons</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">Polygon</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">make_ccw</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">Polygon</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span> <span class="o">=</span> <span class="n">polygons</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pyny3d.Surface needs a ndarray or &#39;</span><span class="o">+</span>\
            <span class="s1">&#39;pyny3d.Polygons as input&#39;</span><span class="p">)</span>
        
        <span class="c1">### Check contiguity</span>
        <span class="k">if</span> <span class="n">check_contiguity</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Surface</span><span class="o">.</span><span class="n">contiguous</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Non-contiguous polygons in the Surface&#39;</span><span class="p">)</span>
        
        <span class="c1">## Holes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">holes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">holes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Polygon</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">make_ccw</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">holes</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">holes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">Polygon</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="n">holes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">melt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">melt</span><span class="p">()</span>
            
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>    
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    
<div class="viewcode-block" id="Surface.lock"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.lock">[docs]</a>    <span class="k">def</span> <span class="nf">lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Precomputes some parameters to run faster specific methods like</span>
<span class="sd">        Surface.classify.</span>
<span class="sd">        </span>
<span class="sd">        Lock the Polygons and generates an index of the sorted areas.</span>
<span class="sd">        </span>
<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">:</span> <span class="n">polygon</span><span class="o">.</span><span class="n">lock</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Surface.seed2pyny"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.seed2pyny">[docs]</a>    <span class="k">def</span> <span class="nf">seed2pyny</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-initialize an object with a seed.</span>
<span class="sd">        </span>
<span class="sd">        :returns: A new ``pyny.Surface``</span>
<span class="sd">        :rtype: ``pyny.Surface``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># import geoms as pyny</span>
        <span class="k">return</span> <span class="n">Surface</span><span class="p">(</span><span class="o">**</span><span class="n">seed</span><span class="p">)</span>
            </div>
<div class="viewcode-block" id="Surface.classify"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.classify">[docs]</a>    <span class="k">def</span> <span class="nf">classify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">already_sorted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the belonging relationship between the polygons</span>
<span class="sd">        in the Surface and a set of points.</span>
<span class="sd">        </span>
<span class="sd">        This function enhances the performance of ``Polygon.contains()``</span>
<span class="sd">        by verifying only the points which are inside the z=0 bounding</span>
<span class="sd">        box of the polygon. To do it fast, it sorts the points and then</span>
<span class="sd">        apply ``Polygon.pip()``.</span>
<span class="sd">        </span>
<span class="sd">        :param points: list of (x, y, z) or (x, y) coordinates of the</span>
<span class="sd">            points to check. (The z value will not be taken into </span>
<span class="sd">            account).</span>
<span class="sd">        :type points: ndarray (shape=(N, 2 or 3))</span>
<span class="sd">        :param edge: If True, consider the points in the Polygon&#39;s edge</span>
<span class="sd">            inside the Polygon.</span>
<span class="sd">        :type edge: bool</span>
<span class="sd">        :param col: Column to sort or already sorted.</span>
<span class="sd">        :type col: int</span>
<span class="sd">        :param already_sorted: If True, the method will consider that</span>
<span class="sd">            the ``points`` are already sorted by the column ``col``.</span>
<span class="sd">        :type already_sorted: bool</span>
<span class="sd">        :returns: Index of the Polygon to which each point belongs. </span>
<span class="sd">            -1 if outside the Surface.</span>
<span class="sd">        :rtype: ndarray (dtpye=int)</span>

<span class="sd">        .. warning:: It is supposed that the Polygons do not overlap </span>
<span class="sd">            each other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="mf">1e-10</span> <span class="k">if</span> <span class="n">edge</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">()</span> <span class="c1"># Precomputes polygons information</span>
        
        <span class="c1"># Sorting the points</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">already_sorted</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyny3d.utils</span> <span class="kn">import</span> <span class="n">sort_numpy</span>
            <span class="c1"># Sorting by the y column can be faster if set_mesh has been</span>
            <span class="c1"># used to generate the points.        </span>
            <span class="n">points</span><span class="p">,</span> <span class="n">order_back</span> <span class="o">=</span> <span class="n">sort_numpy</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">order_back</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="c1"># Computing PiP</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">*-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">pip</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">pip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">sorted_col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>
            <span class="n">sol</span><span class="p">[</span><span class="n">pip</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        
        <span class="c1"># Return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">already_sorted</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sol</span><span class="p">[</span><span class="n">order_back</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sol</span>
</div>
<div class="viewcode-block" id="Surface.intersect_with"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.intersect_with">[docs]</a>    <span class="k">def</span> <span class="nf">intersect_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the intersection between the polygons in this surface</span>
<span class="sd">        and other polygon in the z=0 projection.</span>
<span class="sd">        </span>
<span class="sd">        This method rely fully on the ``shapely.Polygon.intersect_with()``</span>
<span class="sd">        method. The way this method is used is intersecting this polygon</span>
<span class="sd">        recursively with all identified polygons which overlaps with it</span>
<span class="sd">        in the z=0 projection.</span>
<span class="sd">        </span>
<span class="sd">        :param polygon: Polygon to intersect with the Surface.</span>
<span class="sd">        :type polygon: pyny.Polygon</span>
<span class="sd">        :returns: Multiple polygons product of the intersections.</span>
<span class="sd">        :rtype: dict of ndarrays (keys are the number of the polygon</span>
<span class="sd">            inside the surface)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">intersections</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_shapely</span><span class="p">()</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">get_shapely</span><span class="p">()):</span>
                <span class="n">inter</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_shapely</span><span class="p">()</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">get_shapely</span><span class="p">())</span>
                <span class="n">intersections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">inter</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">intersections</span>
            </div>
<div class="viewcode-block" id="Surface.get_plotable3d"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.get_plotable3d">[docs]</a>    <span class="k">def</span> <span class="nf">get_plotable3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: matplotlib Poly3DCollection</span>
<span class="sd">        :rtype: list of mpl_toolkits.mplot3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">polygon</span><span class="o">.</span><span class="n">get_plotable3d</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
       </div>
<div class="viewcode-block" id="Surface.get_domain"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.get_domain">[docs]</a>    <span class="k">def</span> <span class="nf">get_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: opposite vertices of the bounding prism for this </span>
<span class="sd">            object in the form of ndarray([min], [max])</span>
<span class="sd">        </span>
<span class="sd">        .. note:: This method automatically stores the solution in order</span>
<span class="sd">            to do not repeat calculations if the user needs to call it </span>
<span class="sd">            more than once.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">points</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span><span class="o">+</span>
                  <span class="p">[</span><span class="n">holes</span><span class="o">.</span><span class="n">points</span> <span class="k">for</span> <span class="n">holes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">])</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
</div>
<div class="viewcode-block" id="Surface.get_seed"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.get_seed">[docs]</a>    <span class="k">def</span> <span class="nf">get_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect the required information to generate a data estructure </span>
<span class="sd">        that can be used to recreate exactly the same geometry object</span>
<span class="sd">        via *\*\*kwargs*.</span>
<span class="sd">        </span>
<span class="sd">        :returns: Object&#39;s sufficient info to initialize it.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;polygons&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">poly</span><span class="o">.</span><span class="n">points</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
                <span class="s1">&#39;holes&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">hole</span><span class="o">.</span><span class="n">points</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">]}</span>
            
            </div>
<div class="viewcode-block" id="Surface.get_height"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.get_height">[docs]</a>    <span class="k">def</span> <span class="nf">get_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a set of points, computes the z value for the parametric</span>
<span class="sd">        equation of the Polygons in the Surface.</span>
<span class="sd">        </span>
<span class="sd">        This method computes recursively the ``Polygon.get_height()``</span>
<span class="sd">        method for all the Polygons in the Surface, obtaining the z </span>
<span class="sd">        value for the points according to the local Polygon they belong.</span>

<span class="sd">        The points outside the object will have a NaN value in the</span>
<span class="sd">        z column. If the inputed points has a third column the z values</span>
<span class="sd">        outside the Surface&#39;s domain will remain unchanged, the rest</span>
<span class="sd">        will be replaced.</span>

<span class="sd">        :param points: list of coordinates of the points to calculate.</span>
<span class="sd">        :type points: ndarray (shape=(N, 2 or 3))</span>
<span class="sd">        :param edge: If True, consider the points in the Polygon&#39;s edge</span>
<span class="sd">            inside the Polygon.</span>
<span class="sd">        :type edge: bool</span>
<span class="sd">        :returns: (x, y, z) arrays</span>
<span class="sd">        :rtype: ndarray (shape=(N, 3))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">get_height</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">edge</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
            <span class="n">pip</span> <span class="o">=</span> <span class="n">hole</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">points</span><span class="p">[</span><span class="n">pip</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">points</span>
        </div>
<div class="viewcode-block" id="Surface.add_holes"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.add_holes">[docs]</a>    <span class="k">def</span> <span class="nf">add_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">holes_list</span><span class="p">,</span> <span class="n">make_ccw</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add holes to the holes list.</span>
<span class="sd">        </span>
<span class="sd">        :param holes_list: Polygons that will be treated as holes.</span>
<span class="sd">        :type holes_list: list or pyny.Polygon</span>
<span class="sd">        :param make_ccw: If True, points will be sorted ccw.</span>
<span class="sd">        :type make_ccw: bool</span>
<span class="sd">        :returns: None</span>
<span class="sd">        </span>
<span class="sd">        .. note:: The holes can be anywhere, not necesarily on the </span>
<span class="sd">            surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">holes_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span> <span class="n">holes_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">holes_list</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Polygon</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">make_ccw</span><span class="p">)</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">holes_list</span><span class="p">]</span>
                           </div>
<div class="viewcode-block" id="Surface.melt"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.melt">[docs]</a>    <span class="k">def</span> <span class="nf">melt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find and merge groups of polygons in the surface that meet the </span>
<span class="sd">        following criteria:</span>
<span class="sd">        </span>
<span class="sd">            * Are coplanars.</span>
<span class="sd">            * Are contiguous.</span>
<span class="sd">            * The result is convex.</span>
<span class="sd">            </span>
<span class="sd">        This method is very useful reducing the number the items and</span>
<span class="sd">        therefore, the shadowing time computing. Before override this</span>
<span class="sd">        instance, it is saved and can be restored with ``.restore()``</span>
<span class="sd">        </span>
<span class="sd">        :param plot: If True, generates the before and after </span>
<span class="sd">            visualizations for the surface. Use it to check the results.</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :returns: None</span>
<span class="sd">        </span>
<span class="sd">        .. warning:: This method do not check if the merged polygons are </span>
<span class="sd">            actually convex. The convex hull of the union is directly </span>
<span class="sd">            calculated. For this reason, it is very important to visualy</span>
<span class="sd">            check the solution.</span>
<span class="sd">            </span>
<span class="sd">        .. warning:: Some information from the previous state of the </span>
<span class="sd">            surface will be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyny3d.utils</span> <span class="kn">import</span> <span class="n">bool2index</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>
        
        <span class="c1"># First, coplanarity</span>
        <span class="c1">## Normalize parametric equations</span>
        <span class="n">para</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span><span class="o">.</span><span class="n">get_parametric</span><span class="p">()</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">para</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">para</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">para</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">## Coincidences</span>
        <span class="n">cop</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">plane</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">para</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">indexes</span><span class="p">[:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">para</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">plane</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">bool2index</span><span class="p">(</span><span class="n">indexes</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">)))</span>
                <span class="n">para</span><span class="p">[</span><span class="n">pos</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># Second, contiguity</span>
        <span class="n">substituted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cop_cont</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cop</span><span class="p">):</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">Surface</span><span class="o">.</span><span class="n">contiguous</span><span class="p">(</span><span class="n">polygons</span><span class="p">):</span>
                <span class="n">cop_cont</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygons</span><span class="p">)</span>
                <span class="n">substituted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substituted</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
            <span class="n">substituted</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">substituted</span><span class="p">)</span>
                    
            <span class="c1"># Hull        </span>
            <span class="n">merged</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">polygons</span> <span class="ow">in</span> <span class="n">cop_cont</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">polygon</span><span class="o">.</span><span class="n">points</span> 
                                         <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">])</span>
                <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">]))</span>
    
            <span class="c1"># Final substitution</span>
            <span class="n">new_surface</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">))</span>
                                   <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">substituted</span><span class="p">]</span>
            <span class="n">new_surface</span> <span class="o">+=</span> <span class="n">merged</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span> <span class="o">=</span> <span class="n">new_surface</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sorted_areas</span> <span class="o">=</span> <span class="bp">None</span>
            
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Surface.get_area"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.get_area">[docs]</a>    <span class="k">def</span> <span class="nf">get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The area of the surface.</span>
<span class="sd">        </span>
<span class="sd">        .. warning:: The area is computed as the sum of the areas of all</span>
<span class="sd">            the polygons minus the sum of the areas of all the holes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">polygon</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span> <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">hole</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">polys</span><span class="o">-</span><span class="n">holes</span>
</div>
    <span class="nd">@staticmethod</span>        
<div class="viewcode-block" id="Surface.contiguous"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.contiguous">[docs]</a>    <span class="k">def</span> <span class="nf">contiguous</span><span class="p">(</span><span class="n">polygons</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether a set of convex polygons are all contiguous. Two </span>
<span class="sd">        polygons are considered contiguous if they share, at least, two</span>
<span class="sd">        vertices.</span>
<span class="sd">        </span>
<span class="sd">        This is not a complete verification, it is a very simplified</span>
<span class="sd">        one. For a given set of polygons this method will verify that </span>
<span class="sd">        the number of common vertices among them equals or exceeds the</span>
<span class="sd">        minimum number of common vertices possible.</span>
<span class="sd">        </span>
<span class="sd">        This little algorithm will not declare a contiguous set of </span>
<span class="sd">        polygons as non-contiguous, but it can fail in the reverse for </span>
<span class="sd">        certain geometries where polygons have several common vertices</span>
<span class="sd">        among them.</span>
<span class="sd">        </span>
<span class="sd">        :param polygons: List of polygons.</span>
<span class="sd">        :type polygons: list of ``pyny.Polygon``</span>
<span class="sd">        :return: Whether tey are contiguous.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyny3d.utils</span> <span class="kn">import</span> <span class="n">sort_numpy</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygons</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">sort_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">polygon</span><span class="o">.</span><span class="n">points</span> 
                                            <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">polygons</span><span class="p">]))</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Surface.plot2d"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.plot2d">[docs]</a>    <span class="k">def</span> <span class="nf">plot2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_poly</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
               <span class="n">title</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">cbar_label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a 2D plot for the z=0 Surface projection.</span>
<span class="sd">        </span>
<span class="sd">        :param c_poly: Polygons color.</span>
<span class="sd">        :type c_poly: matplotlib color</span>
<span class="sd">        :param alpha: Opacity.</span>
<span class="sd">        :type alpha: float</span>
<span class="sd">        :param cmap: colormap</span>
<span class="sd">        :type cmap: matplotlib.cm</span>
<span class="sd">        :param ret: If True, returns the figure. It can be used to add </span>
<span class="sd">            more elements to the plot or to modify it.</span>
<span class="sd">        :type ret: bool</span>
<span class="sd">        :param title: Figure title.</span>
<span class="sd">        :type title: str</span>
<span class="sd">        :param colorbar: If True, inserts a colorbar in the figure.</span>
<span class="sd">        :type colorbar: bool</span>
<span class="sd">        :param cbar_label: Colorbar right label.</span>
<span class="sd">        :type cbar_label: str</span>
<span class="sd">        :returns: None, axes</span>
<span class="sd">        :rtype: None, matplotlib axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="kn">as</span> <span class="nn">patches</span>
        <span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="kn">as</span> <span class="nn">cm</span>
        
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">polygon</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span> <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Color</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">c_poly</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span> <span class="c1"># Unicolor</span>
            <span class="k">if</span> <span class="n">c_poly</span> <span class="ow">is</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">c_poly</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
            <span class="n">color_vector</span> <span class="o">=</span> <span class="n">c_poly</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
            <span class="n">colorbar</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>                  <span class="c1"># Colormap</span>
            <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">YlOrRd</span>
            <span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="kn">as</span> <span class="nn">mcolors</span>
            <span class="n">normalize</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">c_poly</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">c_poly</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">color_vector</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">c_poly</span><span class="p">))</span>

        <span class="c1"># Plot</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">color_vector</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">patches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                           <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># Colorbar</span>
        <span class="k">if</span> <span class="n">colorbar</span><span class="p">:</span>
            <span class="n">scalarmappaple</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
            <span class="n">scalarmappaple</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">c_poly</span><span class="p">)</span>
            <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scalarmappaple</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">cbar_label</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span> <span class="k">return</span> <span class="n">ax</span>
        </div>
<div class="viewcode-block" id="Surface.iplot"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.iplot">[docs]</a>    <span class="k">def</span> <span class="nf">iplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_poly</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">c_holes</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Improved plot that allows to plot polygons and holes in</span>
<span class="sd">        different colors.</span>
<span class="sd">        </span>
<span class="sd">        :param c_poly: Polygons color.</span>
<span class="sd">        :type c_poly: matplotlib color, &#39;default&#39; or &#39;t&#39; (transparent)</span>
<span class="sd">        :param c_holes: Holes color.</span>
<span class="sd">        :type c_holes: matplotlib color, &#39;default&#39; or &#39;t&#39; (transparent)</span>
<span class="sd">        :param ret: If True, returns the figure. It can be used to add </span>
<span class="sd">            more elements to the plot or to modify it.</span>
<span class="sd">        :type ret: bool</span>
<span class="sd">        :param ax: If a matplotlib axes given, this method will </span>
<span class="sd">            represent the plot on top of this axes. This is used to</span>
<span class="sd">            represent multiple plots from multiple geometries, </span>
<span class="sd">            overlapping them recursively.</span>
<span class="sd">        :type ax: mplot3d.Axes3D, None</span>
<span class="sd">        :returns: None, axes</span>
<span class="sd">        :rtype: None, mplot3d.Axes3D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default parameter</span>
        <span class="k">if</span> <span class="n">c_holes</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">c_holes</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span> <span class="c1"># cyan for the holes</span>
        
        <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_seed</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">c_poly</span> <span class="o">!=</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="n">seed</span><span class="p">[</span><span class="s1">&#39;polygons&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">c_poly</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                                <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">c_holes</span> <span class="o">!=</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="n">seed</span><span class="p">[</span><span class="s1">&#39;holes&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">c_holes</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                             <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span> <span class="k">return</span> <span class="n">ax</span>
            </div>
<div class="viewcode-block" id="Surface.move"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_xyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate the Surface in x, y and z coordinates.</span>
<span class="sd">        </span>
<span class="sd">        :param d_xyz: displacement in x, y(, and z).</span>
<span class="sd">        :type d_xyz: tuple (len=2 or 3)</span>
<span class="sd">        :returns: ``pyny.Surface``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">d_xyz</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">surface</span>
</div>
<div class="viewcode-block" id="Surface.zrotate"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.zrotate">[docs]</a>    <span class="k">def</span> <span class="nf">zrotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Surface which is the same but rotated about a </span>
<span class="sd">        vertical axis.</span>
<span class="sd">        </span>
<span class="sd">        If the axis given is ``None``, the rotation will be computed</span>
<span class="sd">        about the Surface&#39;s centroid.</span>
<span class="sd">        </span>
<span class="sd">        :param angle: Rotation angle (in radians)</span>
<span class="sd">        :type angle: float</span>
<span class="sd">        :param axis: Point in z=0 to perform as rotation axis</span>
<span class="sd">        :type axis: tuple (len=2 or 3) or None</span>
<span class="sd">        :returns: ``pyny.Surface``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">zrotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">surface</span>
</div>
<div class="viewcode-block" id="Surface.mirror"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a symmetry of the Surface respect global axes.</span>
<span class="sd">        </span>
<span class="sd">        :param axes: &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;xy&#39;, &#39;xz&#39;, &#39;yz&#39;...</span>
<span class="sd">        :type axes: str</span>
<span class="sd">        :returns: ``pyny.Surface``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">surface</span>
</div>
<div class="viewcode-block" id="Surface.matrix"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Surface.matrix">[docs]</a>    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the ``pyny.Surface`` itself along a 3D matrix given by the </span>
<span class="sd">        three tuples x, y, z:        </span>

<span class="sd">        :param x: Number of copies and distance between them in this</span>
<span class="sd">            direction.</span>
<span class="sd">        :type x: tuple (len=2)</span>
<span class="sd">        :returns: list of ``pyny.Surface``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">place</span><span class="o">.</span><span class="n">surface</span> <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="n">space</span><span class="p">]</span>

</div></div>
<div class="viewcode-block" id="Polyhedron"><a class="viewcode-back" href="../../tutorial_polyhedron.html#pyny3d.geoms.Polyhedron">[docs]</a><span class="k">class</span> <span class="nc">Polyhedron</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents 3D polygon-based convex polyhedra.</span>
<span class="sd">    </span>
<span class="sd">    Under the hood, ``pyny.Polyhedron`` class uses the ``pyny.Surface``</span>
<span class="sd">    infrastructure to store and operate with the faces (Polygons). This</span>
<span class="sd">    ``pyny.Surface`` can be found in ``Polyhedron.aux_surface``.</span>
<span class="sd">    </span>
<span class="sd">    Instances of this class work as iterable object. When indexed, </span>
<span class="sd">    returns the ``pyny.Polygons`` which conform it.</span>

<span class="sd">    :param polygons: Polygons to be set as the Polyhedron. These </span>
<span class="sd">        Polygons have to be contiguous and form a closed polyhedron\*.</span>
<span class="sd">    :type polygons: list of ndarray, list of ``pyny.Polygon``</span>
<span class="sd">    :param make_ccw: If True, points will be sorted ccw for each </span>
<span class="sd">        polygon.</span>
<span class="sd">    :type make_ccw: bool</span>
<span class="sd">    :returns: None</span>
<span class="sd">    </span>
<span class="sd">    .. note:: \* A concave or open polyhedron will not produce any </span>
<span class="sd">        errors and the code will probably work fine but it is important </span>
<span class="sd">        to keep in mind that ``pyny3d`` was created to work specifically</span>
<span class="sd">        with convex and closed bodies. Future versions of ``pyny3d`` </span>
<span class="sd">        will incorporate functionalities that will raise an error for </span>
<span class="sd">        concave or open Polyhedras.</span>
<span class="sd">    </span>
<span class="sd">    .. warning:: This object do NOT check the contiguity of the </span>
<span class="sd">        polygons or whether the polyhedron is closed or not, even it is</span>
<span class="sd">        actually a requirement.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">make_ccw</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aux_surface</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span> <span class="n">make_ccw</span><span class="o">=</span><span class="n">make_ccw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_surface</span><span class="o">.</span><span class="n">polygons</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>    
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="Polyhedron.seed2pyny"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polyhedron.seed2pyny">[docs]</a>    <span class="k">def</span> <span class="nf">seed2pyny</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-initialize an object with a seed.</span>
<span class="sd">        </span>
<span class="sd">        :returns: A new ``pyny.Polyhedron``</span>
<span class="sd">        :rtype: ``pyny.Polyhedron``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># import geoms as pyny</span>
        <span class="k">return</span> <span class="n">Polyhedron</span><span class="p">(</span><span class="o">**</span><span class="n">seed</span><span class="p">)</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Polyhedron.by_two_polygons"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polyhedron.by_two_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">by_two_polygons</span><span class="p">(</span><span class="n">poly1</span><span class="p">,</span> <span class="n">poly2</span><span class="p">,</span> <span class="n">make_ccw</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Static method. Creates a closed ``pyny.Polyhedron`` connecting </span>
<span class="sd">        two polygons. Both polygons must have the same number of </span>
<span class="sd">        vertices.</span>
<span class="sd">        </span>
<span class="sd">        The rest of its faces will be generated by matching the </span>
<span class="sd">        polygons&#39; vertices two by two.</span>
<span class="sd">        </span>
<span class="sd">        :param poly1: Origin polygon</span>
<span class="sd">        :type poly1: ``pyny.Polygon`` or ndarray (shape=(N, 3))</span>
<span class="sd">        :param poly2: Destination polygon</span>
<span class="sd">        :type poly2: ``pyny.Polygon`` or ndarray (shape=(N, 3))</span>
<span class="sd">        :param make_ccw: If True, points will be sorted ccw for each </span>
<span class="sd">            polygon.</span>
<span class="sd">        :type make_ccw: bool</span>
<span class="sd">        :returns: Polyhedron</span>
<span class="sd">        :rtype: ``pypy.Polyhedron``</span>
<span class="sd">        </span>
<span class="sd">        .. warning:: If an error is raised, probably the Polyhedron</span>
<span class="sd">            have non-planar faces.</span>
<span class="sd">        .. warning:: If the Polyhedra are not created with this method</span>
<span class="sd">            or ``Place.add_extruded_obstacles()``, holes will not be </span>
<span class="sd">            added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">poly1</span><span class="p">)</span> <span class="o">==</span> <span class="n">Polygon</span><span class="p">:</span>
            <span class="n">poly1</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">points</span>
            <span class="n">poly2</span> <span class="o">=</span> <span class="n">poly2</span><span class="o">.</span><span class="n">points</span>
        
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">poly1</span><span class="p">,</span> <span class="n">poly2</span><span class="p">))</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span>
                                      <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,:,</span> <span class="mi">1</span><span class="p">],</span> 
                                      <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> 
                                      <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span> <span class="mi">0</span><span class="p">]]))</span>
        <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly1</span><span class="p">)</span>
        <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">Polyhedron</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span> <span class="n">make_ccw</span><span class="o">=</span><span class="n">make_ccw</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Polyhedron.get_seed"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polyhedron.get_seed">[docs]</a>    <span class="k">def</span> <span class="nf">get_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect the required information to generate a data estructure </span>
<span class="sd">        that can be used to recreate exactly the same geometry object</span>
<span class="sd">        via *\*\*kwargs*.</span>
<span class="sd">        </span>
<span class="sd">        :returns: Object&#39;s sufficient info to initialize it.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;polygons&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_surface</span><span class="o">.</span><span class="n">get_seed</span><span class="p">()[</span><span class="s1">&#39;polygons&#39;</span><span class="p">]}</span>
        </div>
<div class="viewcode-block" id="Polyhedron.get_plotable3d"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polyhedron.get_plotable3d">[docs]</a>    <span class="k">def</span> <span class="nf">get_plotable3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: matplotlib Poly3DCollection</span>
<span class="sd">        :rtype: list of mpl_toolkits.mplot3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_surface</span><span class="o">.</span><span class="n">get_plotable3d</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="Polyhedron.get_domain"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polyhedron.get_domain">[docs]</a>    <span class="k">def</span> <span class="nf">get_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: opposite vertices of the bounding prism for this </span>
<span class="sd">            object.</span>
<span class="sd">        :rtype: ndarray([min], [max])</span>
<span class="sd">        </span>
<span class="sd">        .. note:: This method automatically stores the solution in order</span>
<span class="sd">            to do not repeat calculations if the user needs to call it </span>
<span class="sd">            more than once.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_surface</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="Polyhedron.get_area"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polyhedron.get_area">[docs]</a>    <span class="k">def</span> <span class="nf">get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: The area of the polyhedron.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">polygon</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span> <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_surface</span><span class="p">])</span>
        </div>
<div class="viewcode-block" id="Polyhedron.move"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polyhedron.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_xyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate the Polyhedron in x, y and z coordinates.</span>
<span class="sd">        </span>
<span class="sd">        :param d_xyz: displacement in x, y(, and z).</span>
<span class="sd">        :type d_xyz: tuple (len=2 or 3)</span>
<span class="sd">        :returns: ``pyny.Polyhedron``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">polyhedra</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">d_xyz</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">polyhedra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Polyhedron.zrotate"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polyhedron.zrotate">[docs]</a>    <span class="k">def</span> <span class="nf">zrotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Polyhedron which is the same but rotated about a </span>
<span class="sd">        vertical axis.</span>
<span class="sd">        </span>
<span class="sd">        If the axis given is ``None``, the rotation will be computed</span>
<span class="sd">        about the Polyhedron&#39;s centroid.</span>
<span class="sd">        </span>
<span class="sd">        :param angle: Rotation angle (in radians)</span>
<span class="sd">        :type angle: float</span>
<span class="sd">        :param axis: Point in z=0 to perform as rotation axis</span>
<span class="sd">        :type axis: tuple (len=2 or 3) or None</span>
<span class="sd">        :returns: ``pyny.Polyhedron``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">polyhedra</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">zrotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">polyhedra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Polyhedron.mirror"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polyhedron.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a symmetry of the Polyhedron respect global axes.</span>
<span class="sd">        </span>
<span class="sd">        :param axes: &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;xy&#39;, &#39;xz&#39;, &#39;yz&#39;...</span>
<span class="sd">        :type axes: str</span>
<span class="sd">        :returns: ``pyny.Polyhedron``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">polyhedra</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">polyhedra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Polyhedron.matrix"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Polyhedron.matrix">[docs]</a>    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the ``pyny.Polyhedron`` itself along a 3D matrix given by the </span>
<span class="sd">        three tuples x, y, z:        </span>

<span class="sd">        :param x: Number of copies and distance between them in this</span>
<span class="sd">            direction.</span>
<span class="sd">        :type x: tuple (len=2)</span>
<span class="sd">        :returns: list of ``pyny.Polyhedron``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">Place</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">polyhedra</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">place</span><span class="o">.</span><span class="n">polyhedra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="n">space</span><span class="p">]</span>

</div></div>
<div class="viewcode-block" id="Place"><a class="viewcode-back" href="../../tutorial_place.html#pyny3d.geoms.Place">[docs]</a><span class="k">class</span> <span class="nc">Place</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Agregates one ``pyny.Surface``, one Set of points and an indefinite</span>
<span class="sd">    number of ``pyny.Polyhedra``.</span>
<span class="sd">    </span>
<span class="sd">    Represents the union of a surface with an unlimited number of </span>
<span class="sd">    obstacles. All the elements that conform a Place keep their </span>
<span class="sd">    integrity and functionality, what the Place class makes is to give</span>
<span class="sd">    the possibility to perform higher level operations in these groups</span>
<span class="sd">    of objects.</span>
<span class="sd">    </span>
<span class="sd">    Instances of this class cannot work as iterable object and cannot be</span>
<span class="sd">    indexed.</span>
<span class="sd">    </span>
<span class="sd">    The lower level instances will be stored in:</span>
<span class="sd">        * **Place.surface**</span>
<span class="sd">        * **Place.polyhedra**</span>
<span class="sd">        * **Place.set_of_points**</span>
<span class="sd">    </span>
<span class="sd">    :param surface: This is the only necessary input to create a </span>
<span class="sd">        ``pyny.Place``.</span>
<span class="sd">    :type surface: ``pyny.Surface``, list of ``pyny.Polygon`` or list</span>
<span class="sd">        of ndarray</span>
<span class="sd">    :param polyhedra: ``pyny.Polyhedra`` to attach to the </span>
<span class="sd">        ``pyny.Place``.</span>
<span class="sd">    :type polyhedra: list of ``pyny.Polyhedra``</span>
<span class="sd">    :param set_of_points: Points to attach to the ``pyny.Place``.</span>
<span class="sd">    :type set_of_points: ndarray (shape=(N, 3))</span>
<span class="sd">    :param make_ccw: If True, points will be sorted ccw for each </span>
<span class="sd">        polygon.</span>
<span class="sd">    :type make_ccw: bool</span>
<span class="sd">    :returns: None</span>
<span class="sd">    </span>
<span class="sd">    .. note:: This object is implemented to be used dynamically. Once</span>
<span class="sd">        created, it is possible to add elements, with </span>
<span class="sd">        ``.add_set_of_points``, ``.add_extruded_obstacles`` among others,</span>
<span class="sd">        without replace it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">polyhedra</span><span class="o">=</span><span class="p">[],</span> <span class="n">set_of_points</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
                 <span class="n">make_ccw</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">melt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Creating the object</span>
        <span class="c1">## Surface</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span> <span class="o">==</span> <span class="n">Surface</span><span class="p">:</span> <span class="c1"># Surface object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="n">surface</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span> <span class="c1"># Seed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="o">**</span><span class="n">surface</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="c1"># Simple input</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;polygons&#39;</span><span class="p">:</span> <span class="n">surface</span><span class="p">,</span>
                                      <span class="s1">&#39;make_ccw&#39;</span><span class="p">:</span> <span class="n">make_ccw</span><span class="p">,</span>
                                      <span class="s1">&#39;melt&#39;</span><span class="p">:</span> <span class="n">melt</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pyny3d.Place needs a dict or pyny3d.Surface as input&#39;</span><span class="p">)</span>

        <span class="c1">## Polyhedra</span>
        <span class="k">if</span> <span class="n">polyhedra</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">polyhedra</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span> <span class="n">polyhedra</span> <span class="o">=</span> <span class="p">[</span><span class="n">polyhedra</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">polyhedra</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">Polyhedron</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polyhedra</span> <span class="o">=</span> <span class="n">polyhedra</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polyhedra</span> <span class="o">=</span> <span class="p">[</span><span class="n">Polyhedron</span><span class="p">(</span><span class="n">polyhedron</span><span class="p">,</span> <span class="n">make_ccw</span><span class="p">)</span>
                                  <span class="k">for</span> <span class="n">polyhedron</span> <span class="ow">in</span> <span class="n">polyhedra</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyhedra</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">## Set of points</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">set_of_points</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">set_of_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_of_points</span> <span class="o">=</span> <span class="n">set_of_points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pyny3d.Place has an invalid set_of_points as input&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Place.seed2pyny"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.seed2pyny">[docs]</a>    <span class="k">def</span> <span class="nf">seed2pyny</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-initialize an object with a seed.</span>
<span class="sd">        </span>
<span class="sd">        :returns: A new ``pyny.Place``</span>
<span class="sd">        :rtype: ``pyny.Place``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># import geoms as pyny</span>
        <span class="k">return</span> <span class="n">Place</span><span class="p">(</span><span class="o">**</span><span class="n">seed</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Place.add_set_of_points"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.add_set_of_points">[docs]</a>    <span class="k">def</span> <span class="nf">add_set_of_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new set of points to the existing one without removing it.</span>
<span class="sd">        </span>
<span class="sd">        :param points: Points to be added.</span>
<span class="sd">        :type points: ndarray (shape=(N, 3))</span>
<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_of_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">set_of_points</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span>
        </div>
<div class="viewcode-block" id="Place.get_domain"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.get_domain">[docs]</a>    <span class="k">def</span> <span class="nf">get_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: opposite vertices of the bounding prism for this </span>
<span class="sd">            object.</span>
<span class="sd">        :rtype: ndarray([min], [max])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyhedra</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">polyhedras_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span> 
                                          <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyhedra</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">polyhedras_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_domain</span><span class="p">(),</span> 
                            <span class="n">polyhedras_domain</span><span class="p">,</span> 
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_of_points</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
        </div>
<div class="viewcode-block" id="Place.get_height"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.get_height">[docs]</a>    <span class="k">def</span> <span class="nf">get_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">attach</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                   <span class="n">extra_height</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Launch ``pyny.Surface.get_height(points)`` for the Place&#39;s </span>
<span class="sd">        Surface.</span>
<span class="sd">        </span>
<span class="sd">        This method gives the possibility to store the computed points</span>
<span class="sd">        along with the Place&#39;s set of points. It also make possible to</span>
<span class="sd">        add an extra height (z value) to these points.</span>
<span class="sd">        </span>
<span class="sd">        The points outside the object will have a NaN value in the</span>
<span class="sd">        z column. These point will not be stored but it will be</span>
<span class="sd">        returned.</span>
<span class="sd">         </span>
<span class="sd">        :param points: list of coordinates of the points to calculate.</span>
<span class="sd">        :type points: ndarray (shape=(N, 2 or 3))</span>
<span class="sd">        :param edge: If True, consider the points in the Polygon&#39;s edge</span>
<span class="sd">            inside the Polygon.</span>
<span class="sd">        :type edge: bool</span>
<span class="sd">        :param attach: If True, stores the computed points along with</span>
<span class="sd">            the Place&#39;s set of points.</span>
<span class="sd">        :type attach: bool</span>
<span class="sd">        :param extra_height: Adds an extra height (z value) to the</span>
<span class="sd">            resulting points.</span>
<span class="sd">        :type extra_height: float</span>
<span class="sd">        :returns: (x, y, z)</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_height</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">edge</span><span class="p">)</span>  
        <span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">extra_height</span>
        <span class="k">if</span> <span class="n">attach</span><span class="p">:</span> 
            <span class="n">logic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_set_of_points</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">logic</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span>
</div>
<div class="viewcode-block" id="Place.mesh"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.mesh">[docs]</a>    <span class="k">def</span> <span class="nf">mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">extra_height</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">attach</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a set of points in a mesh that covers the whole Place</span>
<span class="sd">        and computes their height.</span>
<span class="sd">        </span>
<span class="sd">        Generates a xy mesh with a given mesh_size in the </span>
<span class="sd">        Place.surface&#39;s domain and computes the Surface&#39;s height for the</span>
<span class="sd">        nodes. This mesh is alligned with the main directions `x` and </span>
<span class="sd">        `y`.</span>
<span class="sd">        </span>
<span class="sd">        :param mesh_size: distance between points.</span>
<span class="sd">        :type mesh_size: float</span>
<span class="sd">        :param extra_height: Adds an extra height (z value) to the</span>
<span class="sd">            resulting points.</span>
<span class="sd">        :type extra_height: float</span>
<span class="sd">        :param edge: If True, consider the points in the Polygon&#39;s edge</span>
<span class="sd">            inside the Polygon.</span>
<span class="sd">        :type edge: bool</span>
<span class="sd">        :param attach: If True, stores the computed points along with</span>
<span class="sd">            the Place&#39;s set of points.</span>
<span class="sd">        :type attach: bool</span>
<span class="sd">        :returns: (x, y, z)</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Mesh</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
        <span class="n">a</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">mesh_size</span> <span class="c1"># extra bound</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">mesh_size</span>
        <span class="n">x_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh_size</span><span class="p">)</span>
        <span class="n">y_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh_size</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_mesh</span><span class="p">,</span> <span class="n">y_mesh</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
        
        <span class="c1"># Compute and store</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_height</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">edge</span><span class="p">,</span> <span class="n">attach</span><span class="o">=</span><span class="n">attach</span><span class="p">,</span>
                              <span class="n">extra_height</span><span class="o">=</span><span class="n">extra_height</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attach</span><span class="p">:</span> <span class="k">return</span> <span class="n">xyz</span>
            </div>
<div class="viewcode-block" id="Place.clear_set_of_points"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.clear_set_of_points">[docs]</a>    <span class="k">def</span> <span class="nf">clear_set_of_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the points in the Place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_of_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Place.add_holes"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.add_holes">[docs]</a>    <span class="k">def</span> <span class="nf">add_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">holes_list</span><span class="p">,</span> <span class="n">make_ccw</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add holes to the Place&#39;s ``pyny.Surface``.</span>
<span class="sd">        </span>
<span class="sd">        :param holes_list: Polygons that will be treated as holes.</span>
<span class="sd">        :type holes_list: list or ``pyny.Polygon``</span>
<span class="sd">        :param make_ccw: If True, points will be sorted ccw.</span>
<span class="sd">        :type make_ccw: bool</span>
<span class="sd">        :returns: None</span>
<span class="sd">        </span>
<span class="sd">        .. note:: The holes can be anywhere, not necesarily on the </span>
<span class="sd">            surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">add_holes</span><span class="p">(</span><span class="n">holes_list</span><span class="p">,</span> <span class="n">make_ccw</span><span class="o">=</span><span class="n">make_ccw</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Place.add_extruded_obstacles"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.add_extruded_obstacles">[docs]</a>    <span class="k">def</span> <span class="nf">add_extruded_obstacles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">top_polys</span><span class="p">,</span> <span class="n">make_ccw</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add polyhedras to the Place by giving their top polygon and</span>
<span class="sd">        applying extrusion along the z axis.</span>
<span class="sd">        </span>
<span class="sd">        :param top_polys: Polygons to be extruded downwards to the </span>
<span class="sd">            Surface.</span>
<span class="sd">        :type top_polys: list of ``pyny.Polygon``</span>
<span class="sd">        :param make_ccw: If True, points will be sorted ccw.</span>
<span class="sd">        :type make_ccw: bool</span>
<span class="sd">        :returns: None</span>

<span class="sd">        .. note:: When a top polygon is projected downwards and it</span>
<span class="sd">            instersects multiple Surface&#39;s polygons, a independent</span>
<span class="sd">            polyhedron will be created for each individual </span>
<span class="sd">            intersection\*.</span>
<span class="sd">        .. warning:: The top polygons have to be over the Surface, that</span>
<span class="sd">            is, their z=0 projection have to be inside of Surface&#39;s z=0 </span>
<span class="sd">            projection.</span>
<span class="sd">        .. warning:: If the Polyhedra are not created with this method</span>
<span class="sd">            or ``Polyhedron.by_two_polygons()``, holes will not be </span>
<span class="sd">            added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">top_polys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span> <span class="n">top_polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">top_polys</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">poly1</span> <span class="ow">in</span> <span class="n">top_polys</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">poly1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Polygon</span><span class="p">:</span>
                <span class="n">obstacle</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">poly1</span><span class="p">,</span> <span class="n">make_ccw</span><span class="p">)</span>
            <span class="n">intersections_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">intersect_with</span><span class="p">(</span><span class="n">obstacle</span><span class="p">)</span>
            
            <span class="n">base</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">intersections_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_height</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
            <span class="n">base_surf</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="n">base_surf</span><span class="o">.</span><span class="n">melt</span><span class="p">()</span>
            
            <span class="k">for</span> <span class="n">base_poly</span> <span class="ow">in</span> <span class="n">base_surf</span><span class="p">:</span>
                <span class="n">obst_points</span> <span class="o">=</span> <span class="n">obstacle</span><span class="o">.</span><span class="n">get_height</span><span class="p">(</span><span class="n">base_poly</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> 
                                                <span class="n">full</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base_poly</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polyhedra</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polyhedron</span><span class="o">.</span><span class="n">by_two_polygons</span><span class="p">(</span>
                                      <span class="n">base_poly</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> 
                                      <span class="n">obst_points</span><span class="p">,</span> 
                                      <span class="n">make_ccw</span><span class="p">))</span>
            </div>
<div class="viewcode-block" id="Place.get_seed"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.get_seed">[docs]</a>    <span class="k">def</span> <span class="nf">get_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect the required information to generate a data estructure </span>
<span class="sd">        that can be used to recreate exactly the same geometry object</span>
<span class="sd">        via *\*\*kwargs*.</span>
<span class="sd">        </span>
<span class="sd">        :returns: Object&#39;s sufficient info to initialize it.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">seed</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_seed</span><span class="p">()</span>
        <span class="n">polyhedra</span> <span class="o">=</span> <span class="p">[</span><span class="n">polyhedron</span><span class="o">.</span><span class="n">get_seed</span><span class="p">()[</span><span class="s1">&#39;polygons&#39;</span><span class="p">]</span> 
                     <span class="k">for</span> <span class="n">polyhedron</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyhedra</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">polyhedra</span><span class="p">:</span> <span class="n">polyhedra</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seed</span><span class="p">[</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polyhedra</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_of_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">seed</span><span class="p">[</span><span class="s1">&#39;set_of_points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_of_points</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seed</span><span class="p">[</span><span class="s1">&#39;set_of_points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">seed</span>
</div>
<div class="viewcode-block" id="Place.get_plotable3d"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.get_plotable3d">[docs]</a>    <span class="k">def</span> <span class="nf">get_plotable3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: matplotlib Poly3DCollection</span>
<span class="sd">        :rtype: list of mpl_toolkits.mplot3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polyhedra</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">polyhedron</span><span class="o">.</span><span class="n">get_plotable3d</span><span class="p">()</span> 
                         <span class="k">for</span> <span class="n">polyhedron</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyhedra</span><span class="p">],</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="n">polyhedra</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_plotable3d</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Place.iplot"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.iplot">[docs]</a>    <span class="k">def</span> <span class="nf">iplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_poly</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">c_holes</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">c_sop</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
              <span class="n">s_sop</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">extra_height</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Improved plot that allows to plot polygons and holes in</span>
<span class="sd">        different colors and to change the size and the color of the</span>
<span class="sd">        set of points.</span>
<span class="sd">        </span>
<span class="sd">        The points can be plotted accordingly to a ndarray colormap.</span>
<span class="sd">        </span>
<span class="sd">        :param c_poly: Polygons color.</span>
<span class="sd">        :type c_poly: matplotlib color, &#39;default&#39; or &#39;t&#39; (transparent)</span>
<span class="sd">        :param c_holes: Holes color.</span>
<span class="sd">        :type c_holes: matplotlib color, &#39;default&#39; or &#39;t&#39; (transparent)</span>
<span class="sd">        :param c_sop: Set of points color.</span>
<span class="sd">        :type c_sop: matplotlib color or colormap</span>
<span class="sd">        :param s_sop: Set of points size.</span>
<span class="sd">        :type s_sop: float or ndarray</span>
<span class="sd">        :param extra_height: Elevates the points in the visualization.</span>
<span class="sd">        :type extra_height: float</span>
<span class="sd">        :param ret: If True, returns the figure. It can be used to add </span>
<span class="sd">            more elements to the plot or to modify it.</span>
<span class="sd">        :type ret: bool</span>
<span class="sd">        :param ax: If a matplotlib axes given, this method will </span>
<span class="sd">            represent the plot on top of this axes. This is used to</span>
<span class="sd">            represent multiple plots from multiple geometries, </span>
<span class="sd">            overlapping them recursively.</span>
<span class="sd">        :type ax: mplot3d.Axes3D, None</span>
<span class="sd">        :returns: None, axes</span>
<span class="sd">        :rtype: None, mplot3d.Axes3D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">iplot</span><span class="p">(</span><span class="n">c_poly</span><span class="o">=</span><span class="n">c_poly</span><span class="p">,</span> <span class="n">c_holes</span><span class="o">=</span><span class="n">c_holes</span><span class="p">,</span>
                                <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">polyhedron</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyhedra</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">polyhedron</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">c_poly</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c_sop</span> <span class="o">!=</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_of_points</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">extra_height</span><span class="p">,</span> 
                       <span class="n">c</span><span class="o">=</span><span class="n">c_sop</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s_sop</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span> <span class="k">return</span> <span class="n">ax</span>
</div>
<div class="viewcode-block" id="Place.move"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_xyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate the Place in x, y and z coordinates.</span>
<span class="sd">        </span>
<span class="sd">        :param d_xyz: displacement in x, y(, and z).</span>
<span class="sd">        :type d_xyz: tuple (len=2 or 3)</span>
<span class="sd">        :returns: ``pyny.Place``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Space</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">d_xyz</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Place.zrotate"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.zrotate">[docs]</a>    <span class="k">def</span> <span class="nf">zrotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Place which is the same but rotated about a </span>
<span class="sd">        vertical axis.</span>
<span class="sd">        </span>
<span class="sd">        If the axis given is ``None``, the rotation will be computed</span>
<span class="sd">        about the Place&#39;s centroid.</span>
<span class="sd">        </span>
<span class="sd">        :param angle: Rotation angle (in radians)</span>
<span class="sd">        :type angle: float</span>
<span class="sd">        :param axis: Point in z=0 to perform as rotation axis</span>
<span class="sd">        :type axis: tuple (len=2 or 3) or None</span>
<span class="sd">        :returns: ``pyny.Place``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Space</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">zrotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Place.mirror"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a symmetry of the Place respect global axes.</span>
<span class="sd">        </span>
<span class="sd">        :param axes: &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;xy&#39;, &#39;xz&#39;, &#39;yz&#39;...</span>
<span class="sd">        :type axes: str</span>
<span class="sd">        :returns: ``pyny.Place``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Space</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Place.matrix"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Place.matrix">[docs]</a>    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the ``pyny.Place`` itself along a 3D matrix given by the </span>
<span class="sd">        three tuples x, y, z:        </span>

<span class="sd">        :param x: Number of copies and distance between them in this</span>
<span class="sd">            direction.</span>
<span class="sd">        :type x: tuple (len=2)</span>
<span class="sd">        :returns: list of ``pyny.Place``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">place</span> <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="n">space</span><span class="p">]</span>

</div></div>
<div class="viewcode-block" id="Space"><a class="viewcode-back" href="../../tutorial_space.html#pyny3d.geoms.Space">[docs]</a><span class="k">class</span> <span class="nc">Space</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Highest geometry class. Aggregate ``pyny.Places`` to compute </span>
<span class="sd">    operations simultaneously on a group of them. It can be initialized</span>
<span class="sd">    empty.</span>
<span class="sd">    </span>
<span class="sd">    The lower level instances will be stored in:</span>
<span class="sd">        * **Space.places**</span>

<span class="sd">    :param places: Places or empty list.</span>
<span class="sd">    :type places: list of ``pyny.Place``</span>
<span class="sd">    :returns: None</span>

<span class="sd">    Most of the funtionalities of this library are implemented only for</span>
<span class="sd">    ``pyny.Space`` instances, such as compute shadows. Some of most </span>
<span class="sd">    handy are: :func:`move`, :func:`zrotate`, :func:`matrix` or </span>
<span class="sd">    :func:`mirror`. </span>
<span class="sd">    </span>
<span class="sd">    Instances of this class work as iterable object. When indexed, </span>
<span class="sd">    returns the ``pyny.Places`` which conform it.</span>
<span class="sd">    </span>
<span class="sd">    .. note:: This class is implemented to be used dynamically. Once</span>
<span class="sd">        created, it is possible to add elements, with </span>
<span class="sd">        ``.add_places``, ``.add_spaces`` among others, without replace </span>
<span class="sd">        it.</span>
<span class="sd">    .. warning:: Although it is a dynamic class, it is recommended to </span>
<span class="sd">        use the methods to manipulate it. Editing the internal </span>
<span class="sd">        attributes or methods directly can result in a bad behavior.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Empty initializations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">places</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Lock attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locked</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map2seed_schedule</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">explode_map_schedule</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c1"># Creating the object</span>
        <span class="k">if</span> <span class="n">places</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">places</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span> <span class="n">places</span> <span class="o">=</span> <span class="p">[</span><span class="n">places</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">places</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">Place</span><span class="p">:</span> <span class="c1"># Places already initialized</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_places</span><span class="p">(</span><span class="n">places</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">places</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span> <span class="c1"># Initialize the places</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_places</span><span class="p">([</span> <span class="n">Place</span><span class="p">(</span><span class="o">**</span><span class="n">place</span><span class="p">)</span> <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="n">places</span> <span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pyny3d.Space needs a list, dict or &#39;</span><span class="o">+</span>\
                                 <span class="s1">&#39;pyny3d.Place as input&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">places</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">places</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        
<div class="viewcode-block" id="Space.lock"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.lock">[docs]</a>    <span class="k">def</span> <span class="nf">lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lock the Space. Precomputes the map, the seed and some necessary </span>
<span class="sd">        schedules. Speeds up the code significantly by boing most of</span>
<span class="sd">        the big loops just once.</span>
<span class="sd">        </span>
<span class="sd">        This method is automatically launched before shadows</span>
<span class="sd">        computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">locked</span><span class="p">:</span> <span class="k">return</span>
        <span class="kn">from</span> <span class="nn">pyny3d.utils</span> <span class="kn">import</span> <span class="n">bool2index</span>
        <span class="c1"># seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_seed</span><span class="p">()</span>
        
        <span class="c1"># map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">()</span>

        <span class="c1"># map2polygons schedule</span>
        <span class="n">m2p</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># [polygons, holes, sop]</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">()</span>
                
        <span class="c1">## points</span>
        <span class="n">bool_1</span> <span class="o">=</span> <span class="n">index</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">m2p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bool2index</span><span class="p">(</span><span class="n">bool_1</span><span class="p">)</span>
        <span class="n">index_1</span> <span class="o">=</span> <span class="n">bool2index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bool_1</span><span class="p">))</span> <span class="c1"># remain</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">index_1</span><span class="p">]</span>
        
        <span class="c1">## new index</span>
        <span class="n">index_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">index</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mf">1e12</span>
                            <span class="o">+</span><span class="n">index</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1e8</span> 
                            <span class="o">+</span><span class="n">index</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mf">1e4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
        
        <span class="c1">## Dissemination loop</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">index_bool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">index_bool</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dif</span><span class="p">,</span> <span class="n">index_bool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dif</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># hole</span>
                <span class="n">m2p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)])</span>
            <span class="k">if</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># polygon</span>
                <span class="n">m2p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)])</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">explode_map_schedule</span> <span class="o">=</span> <span class="n">m2p</span>

        <span class="c1"># Sort areas</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">explode</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">get_area</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorted_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">areas</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Lock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locked</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Space.seed2pyny"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.seed2pyny">[docs]</a>    <span class="k">def</span> <span class="nf">seed2pyny</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-initialize an object with a seed.</span>
<span class="sd">        </span>
<span class="sd">        :returns: A new ``pyny.Space``</span>
<span class="sd">        :rtype: ``pyny.Space``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Space</span><span class="p">(</span><span class="o">**</span><span class="n">seed</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="Space.add_places"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.add_places">[docs]</a>    <span class="k">def</span> <span class="nf">add_places</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">places</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add pyny.Places to the current space.</span>
<span class="sd">        </span>
<span class="sd">        :param places: Places to add.</span>
<span class="sd">        :type places: list of pyny.Place</span>
<span class="sd">        :param ret: If True, returns the whole updated Space. </span>
<span class="sd">        :type ret: bool</span>
<span class="sd">        :returns: None, ``pyny.Space``</span>
<span class="sd">        </span>
<span class="sd">        .. warning:: This method acts inplace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">places</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span> <span class="n">places</span> <span class="o">=</span> <span class="p">[</span><span class="n">places</span><span class="p">]</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">places</span> <span class="o">+=</span> <span class="n">places</span>
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Space.add_spaces"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.add_spaces">[docs]</a>    <span class="k">def</span> <span class="nf">add_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spaces</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add pyny.Spaces to the current space. In other words, it merges</span>
<span class="sd">        multiple pyny.Spaces in this instance.</span>
<span class="sd">        </span>
<span class="sd">        :param places: ``pyny.Spaces`` to add.</span>
<span class="sd">        :type places: list of pyny.Spaces</span>
<span class="sd">        :param ret: If True, returns the whole updated Space. </span>
<span class="sd">        :type ret: bool</span>
<span class="sd">        :returns: None, ``pyny.Space``</span>
<span class="sd">        </span>
<span class="sd">        .. warning:: This method acts inplace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span> <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">spaces</span><span class="p">]</span>
        <span class="n">Space</span><span class="o">.</span><span class="n">add_places</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">sum</span><span class="p">([</span><span class="n">space</span><span class="o">.</span><span class="n">places</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">],</span> <span class="p">[]))</span>
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Space.get_domain"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.get_domain">[docs]</a>    <span class="k">def</span> <span class="nf">get_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: opposite vertices of the bounding prism for this </span>
<span class="sd">            object.</span>
<span class="sd">        :rtype: ndarray([min], [max])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">place</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span> <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
</div>
<div class="viewcode-block" id="Space.get_seed"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.get_seed">[docs]</a>    <span class="k">def</span> <span class="nf">get_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect the required information to generate a data estructure </span>
<span class="sd">        that can be used to recreate exactly the same geometry object</span>
<span class="sd">        via *\*\*kwargs*.</span>
<span class="sd">        </span>
<span class="sd">        :returns: Object&#39;s sufficient info to initialize it.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;places&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">place</span><span class="o">.</span><span class="n">get_seed</span><span class="p">()</span> <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span>
</div>
<div class="viewcode-block" id="Space.get_plotable3d"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.get_plotable3d">[docs]</a>    <span class="k">def</span> <span class="nf">get_plotable3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: matplotlib Poly3DCollection</span>
<span class="sd">        :rtype: list of mpl_toolkits.mplot3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">place</span><span class="o">.</span><span class="n">get_plotable3d</span><span class="p">()</span> <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="p">[])</span>
        </div>
<div class="viewcode-block" id="Space.get_sets_of_points"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.get_sets_of_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_sets_of_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect all the sets of points for the Places in the Space.</span>
<span class="sd">        </span>
<span class="sd">        :returns: An array with the points of all ``pyny.Places`` which </span>
<span class="sd">            form this ``pyny.Space``.</span>
<span class="sd">        :rtype: ndarray (shape=(N, 3))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">place</span><span class="o">.</span><span class="n">set_of_points</span> <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        </div>
<div class="viewcode-block" id="Space.get_sets_index"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.get_sets_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_sets_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a one dimension array with the Place where the points </span>
<span class="sd">        belong.</span>
<span class="sd">        </span>
<span class="sd">        :returns: The ``pyny.Place`` where the points belong.</span>
<span class="sd">        :rtype: list of int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">place</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">place</span><span class="o">.</span><span class="n">set_of_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Space.get_polygons"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.get_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">get_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect all polygons for the Places in the Space.</span>
<span class="sd">        </span>
<span class="sd">        :returns: The polygons which form the whole ``pyny.Space``.</span>
<span class="sd">        :rtype: list of ``pyny.Polygon``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">place</span><span class="o">.</span><span class="n">set_of_points</span> <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        </div>
<div class="viewcode-block" id="Space.clear_sets_of_points"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.clear_sets_of_points">[docs]</a>    <span class="k">def</span> <span class="nf">clear_sets_of_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears all the sets of points of each ``pyny.Place`` in the </span>
<span class="sd">        Space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="n">place</span><span class="o">.</span><span class="n">set_of_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Space.get_map"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.get_map">[docs]</a>    <span class="k">def</span> <span class="nf">get_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect all the points coordinates from this ``pyny.Space``</span>
<span class="sd">        instance.</span>
<span class="sd">        </span>
<span class="sd">        In order to keep the reference, it returns an index with the</span>
<span class="sd">        following key:</span>
<span class="sd">        </span>
<span class="sd">            * The first column is the Place.</span>
<span class="sd">            * The second column is the body (-1: points, 0: surface, </span>
<span class="sd">                                             n: polyhedron)</span>
<span class="sd">            * The third column is the polygon (-n: holes)</span>
<span class="sd">            * The fourth column is the point.</span>
<span class="sd"> </span>
<span class="sd">        :returns: [index, points]</span>
<span class="sd">        :rtype: list of ndarray</span>

<span class="sd">        .. note:: This method automatically stores the solution in order</span>
<span class="sd">            to do not repeat calculations if the user needs to call it </span>
<span class="sd">            more than once.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_seed</span><span class="p">()[</span><span class="s1">&#39;places&#39;</span><span class="p">]</span> <span class="c1"># template</span>
        
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">place</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
            <span class="c1"># Set of points [_, -1, 0, _]</span>
            <span class="n">n_points</span> <span class="o">=</span> <span class="n">place</span><span class="p">[</span><span class="s1">&#39;set_of_points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n_points</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># It can be False (no set_of_points)</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;set_of_points&#39;</span><span class="p">])</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> 
                                                         <span class="n">n_points</span><span class="p">),</span> 
                                        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_points</span><span class="p">))))</span>
            <span class="c1">#Holes [_, 0, -N, _]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">hole</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;holes&#39;</span><span class="p">]):</span>
                <span class="n">n_points</span> <span class="o">=</span> <span class="n">hole</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span> 
                                                         <span class="n">n_points</span><span class="p">),</span> 
                                        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_points</span><span class="p">))))</span>
            <span class="c1">#Surface [_, 0, N, _]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;polygons&#39;</span><span class="p">]):</span>
                <span class="n">n_points</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">ii</span><span class="p">]]),</span> 
                                                         <span class="n">n_points</span><span class="p">),</span> 
                                        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_points</span><span class="p">))))</span>
            <span class="c1">#Polyhedras [_, N, _, _]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># It can be False (no obstacles)</span>
                <span class="k">for</span> <span class="n">iii</span><span class="p">,</span> <span class="n">polygon_list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polygon_list</span><span class="p">):</span>
                        <span class="n">n_points</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
                        <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">iii</span><span class="p">],</span> 
                                                                  <span class="p">[</span><span class="n">iv</span><span class="p">]]),</span> <span class="n">n_points</span><span class="p">),</span> 
                                                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_points</span><span class="p">))))</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">points</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span>
 </div>
<div class="viewcode-block" id="Space.map2seed"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.map2seed">[docs]</a>    <span class="k">def</span> <span class="nf">map2seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an altered seed from an altered map to produce a </span>
<span class="sd">        transformed ``pyny.Space``.</span>
<span class="sd">        </span>
<span class="sd">        :param map_: the points, and the same order, that appear at </span>
<span class="sd">            ``pyny.Space.get_map()``.</span>
<span class="sd">        :type map_: ndarray (shape=(N, 3))</span>
<span class="sd">        :returns: ``pyny.Space`` seed.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_seed</span><span class="p">()[</span><span class="s1">&#39;places&#39;</span><span class="p">]</span> <span class="c1"># Template</span>
        
        <span class="n">o</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">place</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
            <span class="c1"># Set of points [_, -1, 0, _]</span>
            <span class="k">if</span> <span class="n">place</span><span class="p">[</span><span class="s1">&#39;set_of_points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Maybe no set_of_points</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">place</span><span class="p">[</span><span class="s1">&#39;set_of_points&#39;</span><span class="p">]</span>
                <span class="n">seed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;set_of_points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span> <span class="n">o</span> <span class="o">+</span> <span class="n">polygon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
                <span class="n">o</span> <span class="o">+=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#Holes [_, 0, -N, _]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">hole</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;holes&#39;</span><span class="p">]):</span>
                <span class="n">seed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;holes&#39;</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span> <span class="n">o</span> <span class="o">+</span> <span class="n">hole</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
                <span class="n">o</span> <span class="o">+=</span> <span class="n">hole</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#Surface [_, 0, N, _]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;polygons&#39;</span><span class="p">]):</span>
                <span class="n">seed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;polygons&#39;</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span> <span class="n">o</span> <span class="o">+</span> 
                                                          <span class="n">polygon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
                <span class="n">o</span> <span class="o">+=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#Polyhedras [_, N, _, _]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Maybe no polyhedra</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">polygon_list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">iii</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polygon_list</span><span class="p">):</span>
                        <span class="n">seed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="n">iii</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span> <span class="n">o</span> <span class="o">+</span>
                                                        <span class="n">polygon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
                        <span class="n">o</span> <span class="o">+=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;places&#39;</span><span class="p">:</span> <span class="n">seed</span><span class="p">}</span>
</div>
<div class="viewcode-block" id="Space.map2pyny"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.map2pyny">[docs]</a>    <span class="k">def</span> <span class="nf">map2pyny</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an altered version of this ``pyny.Space`` using an </span>
<span class="sd">        altered map.</span>
<span class="sd">        </span>
<span class="sd">        :param map_: the points, and the same order, that appear at </span>
<span class="sd">            ``pyny.Space.get_map()``.</span>
<span class="sd">        :type map_: ndarray (shape=(N, 3))</span>
<span class="sd">        :returns: ``pyny.Space``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed2pyny</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map2seed</span><span class="p">(</span><span class="n">map_</span><span class="p">))</span>
        </div>
<div class="viewcode-block" id="Space.explode"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.explode">[docs]</a>    <span class="k">def</span> <span class="nf">explode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect all the polygons, holes and points in the Space packaged</span>
<span class="sd">        in a list.</span>
<span class="sd">        </span>
<span class="sd">        :returns: The polygons, the holes and the points.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_seed</span><span class="p">()[</span><span class="s1">&#39;places&#39;</span><span class="p">]</span>
        
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="n">seed</span><span class="p">:</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;set_of_points&#39;</span><span class="p">])</span>
            <span class="n">polygons</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">place</span><span class="p">[</span><span class="s1">&#39;polyhedra&#39;</span><span class="p">],</span> <span class="p">[])</span>
            <span class="n">polygons</span> <span class="o">+=</span> <span class="n">place</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;polygons&#39;</span><span class="p">]</span>
            <span class="n">holes</span> <span class="o">+=</span> <span class="n">place</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;holes&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">polygons</span><span class="p">,</span> <span class="n">holes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
        </div>
<div class="viewcode-block" id="Space.explode_map"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.explode_map">[docs]</a>    <span class="k">def</span> <span class="nf">explode_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Much faster version of ``pyny.Space.explode()`` method for </span>
<span class="sd">        previously locked ``pyny.Space``.</span>
<span class="sd">        </span>
<span class="sd">        :param map_: the points, and the same order, that appear at </span>
<span class="sd">            ``pyny.Space.get_map()``. There is no need for the index if </span>
<span class="sd">            locked.</span>
<span class="sd">        :type map_: ndarray (shape=(N, 3))</span>
<span class="sd">        :returns: The polygons, the holes and the points.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">explode_map_schedule</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="c1"># points</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">index</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">sop</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="c1"># Set of points</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
            
            <span class="c1"># new index</span>
            <span class="n">index_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">index</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mf">1e12</span>
                                <span class="o">+</span><span class="n">index</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1e8</span> 
                                <span class="o">+</span><span class="n">index</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mf">1e4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

            <span class="c1"># Dissemination loop</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">holes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">index_bool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">index_bool</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dif</span><span class="p">,</span> <span class="n">index_bool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dif</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># hole</span>
                    <span class="n">holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">if</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># polygon</span>
                    <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">polygons</span><span class="p">,</span> <span class="n">holes</span><span class="p">,</span> <span class="n">sop</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only points (without index) allowed</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">map_</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">map_</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">explode_map_schedule</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span> <span class="n">points</span><span class="p">[</span><span class="n">p</span> <span class="p">,:]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span>
            <span class="n">holes</span> <span class="o">=</span> <span class="p">[</span> <span class="n">points</span><span class="p">[</span><span class="n">p</span> <span class="p">,:]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ex</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
            <span class="n">sop</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">ex</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">,:]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">polygons</span><span class="p">,</span> <span class="n">holes</span><span class="p">,</span> <span class="n">sop</span><span class="p">]</span>
            </div>
<div class="viewcode-block" id="Space.get_height"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.get_height">[docs]</a>    <span class="k">def</span> <span class="nf">get_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">attach</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                   <span class="n">extra_height</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Launch ``pyny.Place.get_height(points)`` recursively for all </span>
<span class="sd">        the ``pyny.Place`` individually.</span>
<span class="sd">        </span>
<span class="sd">        The points outside the object will have a NaN value in the</span>
<span class="sd">        z column. These point will not be stored but it will be</span>
<span class="sd">        returned.</span>
<span class="sd">         </span>
<span class="sd">        :param points: list of coordinates of the points to calculate.</span>
<span class="sd">        :type points: ndarray (shape=(N, 2 or 3))</span>
<span class="sd">        :param edge: If True, consider the points in the Polygon&#39;s edge</span>
<span class="sd">            inside the Polygon.</span>
<span class="sd">        :type edge: bool</span>
<span class="sd">        :param attach: If True, stores the computed points along with</span>
<span class="sd">            the Place&#39;s set of points.</span>
<span class="sd">        :type attach: bool</span>
<span class="sd">        :param extra_height: Adds an extra height (z value) to the</span>
<span class="sd">            resulting points.</span>
<span class="sd">        :type extra_height: float</span>
<span class="sd">        :returns: (x, y, z)</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">place</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">place</span><span class="o">.</span><span class="n">get_height</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">attach</span><span class="p">,</span>
                                      <span class="n">extra_height</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attach</span><span class="p">:</span> <span class="k">return</span> <span class="n">xyz</span>
        </div>
<div class="viewcode-block" id="Space.mesh"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.mesh">[docs]</a>    <span class="k">def</span> <span class="nf">mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">extra_height</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">attach</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Launch `pyny.Place.mesh(points)` recursively for all </span>
<span class="sd">        the ``pyny.Place`` individually.</span>
<span class="sd">        </span>
<span class="sd">        :param mesh_size: distance between points.</span>
<span class="sd">        :type mesh_size: float</span>
<span class="sd">        :param extra_height: Adds an extra height (z value) to the</span>
<span class="sd">            resulting points.</span>
<span class="sd">        :type extra_height: float</span>
<span class="sd">        :param edge: If True, consider the points in the Polygon&#39;s edge</span>
<span class="sd">            inside the Polygon.</span>
<span class="sd">        :type edge: bool</span>
<span class="sd">        :param attach: If True, stores the computed points along with</span>
<span class="sd">            the Place&#39;s set of points.</span>
<span class="sd">        :type attach: bool</span>
<span class="sd">        :returns: (x, y, z)</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">place</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">mesh_size</span><span class="p">,</span> <span class="n">extra_height</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">attach</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="Space.move"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_xyz</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate the whole Space in x, y and z coordinates.</span>
<span class="sd">        </span>
<span class="sd">        :param d_xyz: displacement in x, y(, and z).</span>
<span class="sd">        :type d_xyz: tuple (len=2 or 3)</span>
<span class="sd">        :param inplace: If True, the moved ``pyny.Space`` is copied and </span>
<span class="sd">            added to the current ``pyny.Space``. If False, it returns </span>
<span class="sd">            the new ``pyny.Space``.</span>
<span class="sd">        :type inplace: bool</span>
<span class="sd">        :returns: None, ``pyny.Space``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span>
        <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_xyz</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">d_xyz</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d_xyz</span><span class="p">)</span>
        
        <span class="c1"># Add (dx, dy, dz) to all the coordinates</span>
        <span class="n">map_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xyz</span>
        <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2pyny</span><span class="p">(</span><span class="n">map_</span><span class="p">)</span>
        
        <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_spaces</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">space</span>
</div>
<div class="viewcode-block" id="Space.zrotate"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.zrotate">[docs]</a>    <span class="k">def</span> <span class="nf">zrotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Space which is the same but rotated about a </span>
<span class="sd">        vertical axis.</span>
<span class="sd">        </span>
<span class="sd">        If the axis given is ``None``, the rotation will be computed</span>
<span class="sd">        about the Space&#39;s centroid.</span>
<span class="sd">        </span>
<span class="sd">        :param angle: Rotation angle (in radians)</span>
<span class="sd">        :type angle: float</span>
<span class="sd">        :param axis: Point in z=0 to perform as rotation axis</span>
<span class="sd">        :type axis: tuple (len=2 or 3) or None</span>
<span class="sd">        :returns: ``pyny.Space``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span>
        <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_centroid</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
            
        <span class="n">map_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">axis</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="n">rotated_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">map_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">map_</span> <span class="o">=</span> <span class="n">rotated_</span> <span class="o">+</span> <span class="n">axis</span>
        
        <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2pyny</span><span class="p">(</span><span class="n">map_</span><span class="p">)</span>
        <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">return</span> <span class="n">space</span>
</div>
<div class="viewcode-block" id="Space.matrix"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.matrix">[docs]</a>    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the ``pyny.Space`` itself along a 3D matrix given by the </span>
<span class="sd">        three tuples x, y, z:        </span>

<span class="sd">        :param x: Number of copies and distance between them in this</span>
<span class="sd">            direction.</span>
<span class="sd">        :type x: tuple (len=2)</span>
<span class="sd">        :param inplace: If True, the moved ``pyny.Space`` is copied and </span>
<span class="sd">            added to the current ``pyny.Space``. If False, it returns </span>
<span class="sd">            the new ``pyny.Space``.</span>
<span class="sd">        :type inplace: bool        </span>
<span class="sd">        :returns: None, ``pyny.Space``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span>
        <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base</span><span class="p">:</span> <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">single</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">base</span><span class="o">.</span><span class="n">add_spaces</span><span class="p">(</span><span class="n">single</span><span class="o">.</span><span class="n">move</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base</span><span class="p">:</span> <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">single</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                <span class="n">base</span><span class="o">.</span><span class="n">add_spaces</span><span class="p">(</span><span class="n">single</span><span class="o">.</span><span class="n">move</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>           
            <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base</span><span class="p">:</span> <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">single</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">z</span><span class="p">:</span>
                <span class="n">base</span><span class="o">.</span><span class="n">add_spaces</span><span class="p">(</span><span class="n">single</span><span class="o">.</span><span class="n">move</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
        
        <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">places</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_spaces</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base</span>
            </div>
<div class="viewcode-block" id="Space.mirror"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a symmetry of the Space respect global axes.</span>
<span class="sd">        </span>
<span class="sd">        :param axes: &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;xy&#39;, &#39;xz&#39;, &#39;yz&#39;...</span>
<span class="sd">        :type axes: str</span>
<span class="sd">        :param inplace: If True, the new ``pyny.Space`` is copied and </span>
<span class="sd">            added to the current ``pyny.Space``. If False, it returns </span>
<span class="sd">            the new ``pyny.Space``.</span>
<span class="sd">        :type inplace: bool        </span>
<span class="sd">        :returns: None, ``pyny.Space``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span>
        <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">mirror</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">mirror</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;y&#39;</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">mirror</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">mirror</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="n">map_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mirror</span>
        <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2pyny</span><span class="p">(</span><span class="n">map_</span><span class="p">)</span>
        
        <span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_spaces</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">space</span>
</div>
<div class="viewcode-block" id="Space.photo"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.photo">[docs]</a>    <span class="k">def</span> <span class="nf">photo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">azimuth_zenit</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a change of the reference system for the whole </span>
<span class="sd">        ``pyny.Space`` to align the `y` axis with a given direction. </span>
<span class="sd">        Returns its elements (polygons, holes, points) extracted in a</span>
<span class="sd">        list.</span>
<span class="sd">        </span>
<span class="sd">        In its conception, this method was created as a tool for the </span>
<span class="sd">        shadows computation by calculating &quot;what is in front and what </span>
<span class="sd">        is behind to the look of the Sun&quot;. For this reason, the </span>
<span class="sd">        direction is given in spherical coordinates by two angles: the </span>
<span class="sd">        azimth and the zenit.</span>
<span class="sd">        </span>
<span class="sd">            * The azimuth is zero when pointing to the South, -pi/4 to </span>
<span class="sd">              the East, pi/4 to the West and pi/2 to the North.</span>
<span class="sd">            * The zenit is zero at the ground level and pi/4 &quot;pointing</span>
<span class="sd">              completely orthogonal to the sky&quot;.</span>
<span class="sd">        </span>
<span class="sd">        In short, this methods answer &quot;How would the ``pyny.Space`` look</span>
<span class="sd">        in a photograph taken from an arbitrary direction in cylindrical </span>
<span class="sd">        perpective?&quot;</span>
<span class="sd">        </span>
<span class="sd">        The photograph has a new reference system: x, y, depth. The sign</span>
<span class="sd">        of the new depth coordinate has to be checked before assuming </span>
<span class="sd">        what is closer and what is further inasmuch as it changes</span>
<span class="sd">        depending on the direction of the photo.</span>
<span class="sd">        </span>
<span class="sd">        :param azimuth_zenit: Direction of the photo in spherical </span>
<span class="sd">            coordinates and in radians.</span>
<span class="sd">        :type azimuth_zenit: tuple</span>
<span class="sd">        :param plot: If True, is shows the photo visualization.</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :returns: Exploded ``pyny.Space``</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">()</span>
        
        <span class="n">a</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">azimuth_zenit</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)],</span>
                      <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">z</span><span class="p">)],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">z</span><span class="p">)]])</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># Here it is in self.Space coordinates</span>
            
        <span class="c1"># Coordinate change</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">G</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">G</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">G</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span> <span class="c1"># Photograph coordinate</span>
        <span class="n">poly_hole_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">explode_map</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">polygons</span><span class="p">,</span> <span class="n">holes</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="n">poly_hole_points</span>
            <span class="n">aux_surface</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">holes</span><span class="p">,</span> <span class="n">make_ccw</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">aux_surface</span><span class="o">.</span><span class="n">plot2d</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;#990000&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">poly_hole_points</span>
            </div>
<div class="viewcode-block" id="Space.iplot"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.iplot">[docs]</a>    <span class="k">def</span> <span class="nf">iplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">places</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_poly</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">c_holes</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> 
              <span class="n">c_sop</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">s_sop</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Improved plot that allows to plot polygons and holes in</span>
<span class="sd">        different colors and to change the size and the color of the</span>
<span class="sd">        set of points.</span>
<span class="sd">        </span>
<span class="sd">        The points can be plotted accordingly to a ndarray colormap.</span>
<span class="sd">        </span>
<span class="sd">        :param c_poly: Polygons color.</span>
<span class="sd">        :type c_poly: matplotlib color, &#39;default&#39; or &#39;t&#39; (transparent)</span>
<span class="sd">        :param c_holes: Holes color.</span>
<span class="sd">        :type c_holes: matplotlib color, &#39;default&#39; or &#39;t&#39; (transparent)</span>
<span class="sd">        :param c_sop: Set of points color.</span>
<span class="sd">        :type c_sop: matplotlib color or colormap</span>
<span class="sd">        :param s_sop: Set of points size.</span>
<span class="sd">        :type s_sop: float or ndarray</span>
<span class="sd">        :param ret: If True, returns the figure. It can be used to add </span>
<span class="sd">            more elements to the plot or to modify it.</span>
<span class="sd">        :type ret: bool</span>
<span class="sd">        :param ax: If a matplotlib axes given, this method will </span>
<span class="sd">            represent the plot on top of this axes. This is used to</span>
<span class="sd">            represent multiple plots from multiple geometries, </span>
<span class="sd">            overlapping them recursively.</span>
<span class="sd">        :type ax: mplot3d.Axes3D, None</span>
<span class="sd">        :returns: None, axes</span>
<span class="sd">        :rtype: None, mplot3d.Axes3D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">places</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> 
            <span class="n">places</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">places</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">places</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">places</span> <span class="o">=</span> <span class="p">[</span><span class="n">places</span><span class="p">]</span>
            
        <span class="n">places</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">places</span><span class="p">)</span>
        <span class="n">places</span><span class="p">[</span><span class="n">places</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">places</span><span class="p">)</span> <span class="o">+</span> <span class="n">places</span><span class="p">[</span><span class="n">places</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">places</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">places</span><span class="p">)</span>
        
        <span class="n">aux_space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">places</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">place</span> <span class="ow">in</span> <span class="n">aux_space</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">place</span><span class="o">.</span><span class="n">iplot</span><span class="p">(</span><span class="n">c_poly</span><span class="p">,</span> <span class="n">c_holes</span><span class="p">,</span> <span class="n">c_sop</span><span class="p">,</span> <span class="n">s_sop</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">aux_space</span><span class="o">.</span><span class="n">center_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span> <span class="k">return</span> <span class="n">ax</span>
</div>
<div class="viewcode-block" id="Space.shadows"><a class="viewcode-back" href="../../doc.html#pyny3d.geoms.Space.shadows">[docs]</a>    <span class="k">def</span> <span class="nf">shadows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">latitude</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">init</span><span class="o">=</span><span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initializes a ShadowManager object for this ``pyny.Space`` </span>
<span class="sd">        instance.</span>
<span class="sd">        </span>
<span class="sd">        The &#39;empty&#39; initialization accepts ``data`` and ``t`` and ``dt``</span>
<span class="sd">        but the ShadowsManager will not start the calculations. It will</span>
<span class="sd">        wait the user to manually insert the rest of the parameters.</span>
<span class="sd">        Call ``ShadowsManager.run()`` to start the shadowing </span>
<span class="sd">        computations.</span>
<span class="sd">        </span>
<span class="sd">        The &#39;auto&#39; initialization pre-sets all the minimum parameters to</span>
<span class="sd">        run the computations\*. The available resolutions are:</span>
<span class="sd">        </span>
<span class="sd">            * &#39;low&#39;</span>
<span class="sd">            * &#39;mid&#39;</span>
<span class="sd">            * &#39;high&#39;</span>
<span class="sd">            </span>
<span class="sd">        The &#39;auto&#39; mode will use all the arguments different than </span>
<span class="sd">        ``None`` and the ``set_of_points`` of the ``pyny.Space`` if any.</span>
<span class="sd">            </span>
<span class="sd">        :param data: Data timeseries to project on the 3D model </span>
<span class="sd">            (radiation, for example).</span>
<span class="sd">        :type data: ndarray (shape=N), None</span>
<span class="sd">        :param t: Time vector in absolute minutes or datetime objects</span>
<span class="sd">        :type t: ndarray or list, None</span>
<span class="sd">        :param dt: Interval time to generate t vector.</span>
<span class="sd">        :type dt: int, None</span>
<span class="sd">        :param latitude: Local latitude.</span>
<span class="sd">        :type latitude: float (radians)</span>
<span class="sd">        :param init: Initialization mode</span>
<span class="sd">        :type init: str</span>
<span class="sd">        :param init: Resolution for the time vector generation (if </span>
<span class="sd">            ``None``), for setting the sensible points and for the </span>
<span class="sd">            Voronoi diagram.</span>
<span class="sd">        :type init: str</span>
<span class="sd">        :returns: ``ShadowsManager`` object</span>
<span class="sd">        </span>
<span class="sd">        .. warning:: \* The latitude is set in 0.65 rads (37º) by </span>
<span class="sd">            default.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">pyny3d.shadows</span> <span class="kn">import</span> <span class="n">ShadowsManager</span>
        
        <span class="k">if</span> <span class="n">init</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="c1"># Resolution</span>
            <span class="k">if</span> <span class="n">resolution</span> <span class="o">==</span> <span class="s1">&#39;low&#39;</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="k">elif</span> <span class="n">resolution</span> <span class="o">==</span> <span class="s1">&#39;mid&#39;</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mi">30</span>
            <span class="k">elif</span> <span class="n">resolution</span> <span class="o">==</span> <span class="s1">&#39;high&#39;</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mi">60</span>
            <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">dt</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">/</span><span class="n">factor</span>
            <span class="k">if</span> <span class="n">latitude</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">latitude</span> <span class="o">=</span> <span class="mf">0.65</span>
            
            <span class="c1"># Autofill ShadowsManager Object</span>
            <span class="n">sm</span> <span class="o">=</span> <span class="n">ShadowsManager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> 
                                <span class="n">latitude</span><span class="o">=</span><span class="n">latitude</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sets_of_points</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">max_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_domain</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="n">sm</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">mesh_size</span><span class="o">=</span><span class="n">max_bound</span><span class="o">/</span><span class="n">factor</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c1">## General parameters</span>
            <span class="n">sm</span><span class="o">.</span><span class="n">arg_vor_size</span> <span class="o">=</span> <span class="mi">6</span><span class="o">/</span><span class="n">factor</span>
            <span class="n">sm</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">sm</span>
            
        <span class="k">elif</span> <span class="n">init</span> <span class="o">==</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ShadowsManager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> 
                                  <span class="n">latitude</span><span class="o">=</span><span class="n">latitude</span><span class="p">)</span>
</pre></div></div></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, José Antonio Fernández-Fernández.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>