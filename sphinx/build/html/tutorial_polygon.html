<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Polygon tutorial &mdash; pyny3d 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyny3d 0.1 documentation" href="index.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>pyny3d 0.1 documentation</span></a></h1>
        <h2 class="heading"><span>Polygon tutorial</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <p>Back to <a class="reference internal" href="tutorial.html#tutorials"><span>Tutorials</span></a></p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#polygon-tutorial" id="id3">Polygon tutorial</a><ul>
<li><a class="reference internal" href="#non-trivial-methods" id="id4">Non-trivial methods</a><ul>
<li><a class="reference internal" href="#get-parametric" id="id5">get_parametric</a></li>
<li><a class="reference internal" href="#to-2d" id="id6">to_2d</a></li>
<li><a class="reference internal" href="#contains" id="id7">contains</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="polygon-tutorial">
<span id="tutorial-polygon"></span><h1><a class="toc-backref" href="#id3">Polygon tutorial</a><a class="headerlink" href="#polygon-tutorial" title="Permalink to this headline">¶</a></h1>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="_images/polygon.png"><img alt="_images/polygon.png" src="_images/polygon.png" style="width: 560.0px; height: 417.9px;" /></a>
<p class="caption"><span class="caption-text"><em>Example of a triangle given by three points:
[[0, 0, 0], [5, 0, 0], [2.5, 2.5, 2]]</em></span></p>
</div>
<span class="target" id="module-pyny3d.geoms"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">pyny3d.geoms.</code><code class="descname">Polygon</code><span class="sig-paren">(</span><em>points</em>, <em>make_ccw=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyny3d/geoms.html#Polygon"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Basic geometry object. It generates and stores all the information
relative to a polygon in 3D.</p>
<p>Instances of this class work as iterable object. When indexed, 
returns the points which conform it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>points</strong> (ndarray <em>shape=(N, 2 or 3)</em>) &#8211; np.array with the sorted points which form the 
polygon (xyz or xy). Do not repeat the first point at the end.</li>
<li><strong>make_ccw</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; If True, points will be sorted ccw.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This object can be locked (<code class="docutils literal"><span class="pre">.lock()</span></code> method) in order to 
precompute the domain and the path for faster further 
computations.</p>
</div>
</dd></dl>

<p>First of all, if performance is important in your use of <code class="docutils literal"><span class="pre">pyny3d</span></code> you must
control the ccw verification. It is active by default but it can be switched
off if you are sure that the Polygons you are going to introduce are well
ccw ordered. The time expended in the verification can be very high:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="go">     ...: import pyny3d.geoms as pyny</span>
<span class="go">     ...: polygon = np.array([[0,0,0], [7,0,0], [7,10,2], [0,10,2]])</span>

<span class="gp">In [2]: </span><span class="o">%</span><span class="k">timeit</span> pyny.Polygon(polygon)
<span class="go">100 loops, best of 3: 2.27 ms per loop</span>

<span class="gp">In [3]: </span><span class="n">pyny</span><span class="o">.</span><span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="bp">False</span>

<span class="gp">In [4]: </span><span class="o">%</span><span class="k">timeit</span> pyny.Polygon(polygon)
<span class="go">1000000 loops, best of 3: 1.8 µs per loop</span>
</pre></div>
</div>
<p>The rest of classes are affected exactly the same:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [5]: </span><span class="n">pyny</span><span class="o">.</span><span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="bp">True</span>

<span class="gp">In [6]: </span><span class="n">surface_poly</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">]]),</span>
<span class="gp">   ...: </span>                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mf">3.5</span><span class="p">]]),</span>
<span class="gp">   ...: </span>                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mf">3.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mf">3.5</span><span class="p">]]),</span>
<span class="gp">   ...: </span>                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mf">3.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mf">3.5</span><span class="p">]])]</span>
<span class="gp">   ...: </span>

<span class="gp">In [7]: </span><span class="o">%</span><span class="k">timeit</span> pyny.Place(surface_poly)
<span class="go">100 loops, best of 3: 9.89 ms per loop</span>

<span class="gp">In [8]: </span><span class="n">pyny</span><span class="o">.</span><span class="n">Polygon</span><span class="o">.</span><span class="n">verify</span> <span class="o">=</span> <span class="bp">False</span>

<span class="gp">In [9]: </span><span class="o">%</span><span class="k">timeit</span> pyny.Place(surface_poly)
<span class="go">100000 loops, best of 3: 11.7 µs per loop</span>
</pre></div>
</div>
<div class="section" id="non-trivial-methods">
<h2><a class="toc-backref" href="#id4">Non-trivial methods</a><a class="headerlink" href="#non-trivial-methods" title="Permalink to this headline">¶</a></h2>
<p>This class, for being the lowest (and the simplest), does actually not require
great explanations. Instead, non-trivial functions will be commented. Trivial
methods are considered those which are easy enough to be understood
just with the documentation given in <a class="reference internal" href="doc.html#doc-polygon"><span>Polygon</span></a>. On the other hand, the
non-trivial methods can cause problems if they are not properly observed in
action.</p>
<p><strong>Trivial methods:</strong></p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">method</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>.get_path()</td>
<td>Returns the matplotlib.path.Path of the z=0 projection</td>
</tr>
<tr class="row-odd"><td>.get_shapely()</td>
<td>Returns the shapely.Polygon of the z=0 projection</td>
</tr>
<tr class="row-even"><td>.get_area()</td>
<td>Returns the real area</td>
</tr>
<tr class="row-odd"><td>.get_height()</td>
<td>Returns the z value for the parametric equation for
a list of points</td>
</tr>
<tr class="row-even"><td>.is_convex()</td>
<td>Returns whether a polygon is convex</td>
</tr>
<tr class="row-odd"><td>.make_ccw()</td>
<td>Changes the order of a set of points to be ccw</td>
</tr>
<tr class="row-even"><td>.lock()</td>
<td>Precomputes some values to speedup shadowing</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The methods to <strong>transform</strong> the classes are explained in detail separately
in <a class="reference internal" href="tutorial_transformations.html#tutorial-transformations"><span>Transformations</span></a>.</p>
<p>The <code class="docutils literal"><span class="pre">.pip()</span></code> method is discussed separately in
<a class="reference internal" href="tutorial_pip_and_classify.html#tutorial-pip-and-classify"><span>PiP and Classify tutorial</span></a>.</p>
<div class="section" id="get-parametric">
<h3><a class="toc-backref" href="#id5">get_parametric</a><a class="headerlink" href="#get-parametric" title="Permalink to this headline">¶</a></h3>
<p>Computes the parametric equation of the plane that contains
the polygon. The output has the form np.array([a, b, c, d])
for:</p>
<div class="math">
\[a*x + b*y + c*z + d = 0\]</div>
<p>What makes <em>non-trivial</em> this method is that it can verify whether the Polygon
is contained in a plane or not. If <code class="docutils literal"><span class="pre">check</span></code> argument is <code class="docutils literal"><span class="pre">True</span></code>, the program
will raise an error.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [10]: </span><span class="n">polygon</span> <span class="o">=</span> <span class="n">pyny</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">]]))</span>
<span class="go">    ...: polygon.get_parametric(True, tolerance=0.01)</span>
<span class="gh">Out[10]: </span><span class="go">array([0, 14, -70, 0])</span>

<span class="gp">In [11]: </span><span class="n">non_polygon</span> <span class="o">=</span> <span class="n">pyny</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">99</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">]]))</span>
<span class="go">    ...: non_polygon.get_parametric(True, tolerance=0.01)</span>
<span class="go">ValueError: Polygon not plane:</span>
<span class="go">[[0  0 -99]</span>
<span class="go"> [7  0  0]</span>
<span class="go"> [7 10  2]</span>
<span class="go"> [0 10  2]]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This verification is not executed automatically. If it is
required, the only way to do it is by requesting the parametric equation.</p>
</div>
</div>
<div class="section" id="to-2d">
<h3><a class="toc-backref" href="#id6">to_2d</a><a class="headerlink" href="#to-2d" title="Permalink to this headline">¶</a></h3>
<p>Generates the real 2D polygon of the 3D polygon.</p>
<p>This library mostly uses the z=0 projection to perform
operations with the polygons. For this reason, if real 2D
planar operations are required (draw a real matplotlib.path,
calculate real area...) the best way is to create a new
<code class="docutils literal"><span class="pre">pyny.Polygon</span></code> with this method.</p>
<p>What it actually does is to calculate the 3D rotation matrix that performs
a turn which put the Polygon in the z=0 plane.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [12]: </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="go">...: polygon = pyny.Polygon(np.array([[0,0,0], [5,0,0], [2.5,2.5,99]]))</span>
<span class="go">...: polygon.plot2d()</span>
<span class="go">...:</span>
<span class="go">...: polygon.to_2d().plot2d()</span>
<span class="go">...: plt.axis(&#39;equal&#39;)</span>
</pre></div>
</div>
<div class="figure align-center" id="id2">
<a class="reference internal image-reference" href="_images/before.png"><img alt="_images/before.png" src="_images/before.png" style="width: 863.4px; height: 317.4px;" /></a>
<p class="caption"><span class="caption-text"><em>Zenital view of the tilted triangle and the real triangle in z=0</em></span></p>
</div>
</div>
<div class="section" id="contains">
<h3><a class="toc-backref" href="#id7">contains</a><a class="headerlink" href="#contains" title="Permalink to this headline">¶</a></h3>
<p>This method applies the Point in Polygon algorithm for an arbitrary number of
points and one polygon (without its z position). It depends completely on
<code class="docutils literal"><span class="pre">matplotlib.path.Path.contains_points</span></code>. The only added modification is that
original <code class="docutils literal"><span class="pre">radius</span></code> float argument has been replaced with <code class="docutils literal"><span class="pre">edge</span></code> boolean
argument.</p>
<p>The method was created primarily for cleanliness. Compare this two identical
commands:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [13]: </span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mf">5.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="gp">In [14]: </span><span class="n">polygon</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
<span class="gh">Out[14]: </span><span class="go">array([True, False, True, False, False], dtype=bool)</span>

<span class="gp">In [15]: </span><span class="n">polygon</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gh">Out[15]: </span><span class="go">array([True, False, True, False, False], dtype=bool)</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Next tutorial: <a class="reference internal" href="tutorial_surface.html#tutorial-surface"><span>Surface tutorial</span></a></p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, José Antonio Fernández-Fernández.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>